<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fractal Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.4.3/decimal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; touch-action: none; }
        .noselect { -webkit-user-select: none; user-select: none; }
        canvas { display: block; touch-action: none; }
        /* Scrollbar customization for the UI panel */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.4); }
    </style>
</head>
<body class="text-white font-sans antialiased noselect">
    <!-- PixiJS Container -->
    <div id="canvas-container-basic" class="absolute inset-0 z-0"></div>
    <div id="canvas-container-advanced" class="absolute inset-0 z-0 hidden"></div>

    <!-- Export Frame Overlay (Hidden by default) -->
    <div id="export-frame" class="absolute hidden border-2 border-dashed border-yellow-400 pointer-events-none z-50 shadow-[0_0_15px_rgba(255,255,0,0.5)]">
        <div class="absolute top-2 left-2 bg-yellow-400 text-black text-[10px] font-bold px-1 rounded opacity-80">EXPORT AREA (16:9)</div>
    </div>

    <!-- UI Container -->
    <div id="ui-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 flex flex-col justify-between p-4">

        <!-- Header / Top Bar -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="bg-black/60 backdrop-blur-md rounded-lg p-3 border border-white/10 shadow-lg">
                <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">Fractal Explorer</h1>
                <p class="text-xs text-gray-400 mb-2">Navigate the infinite</p>
                <!-- Tabs -->
                <div class="flex gap-2 border-t border-white/10 pt-2">
                    <button id="tab-basic" class="text-xs font-bold bg-blue-600/50 text-white px-2 py-1 rounded hover:bg-blue-600 transition">Basic</button>
                    <button id="tab-advanced" class="text-xs font-bold bg-transparent text-gray-400 px-2 py-1 rounded hover:bg-white/10 transition">Advanced</button>
                </div>
            </div>

            <div class="flex gap-2">
                <button id="btn-save-fav" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Save Favorite">
                    <svg class="w-5 h-5 text-pink-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>
                </button>
                <button id="btn-favorites" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="View Favorites">
                    <svg class="w-5 h-5 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                </button>
                <button id="btn-undo" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Undo Zoom">
                    <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
                </button>
                <button id="btn-reset" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Reset View">
                    <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m-15.357-2a8.001 8.001 0 0015.357-2m0 0H15"></path></svg>
                </button>
            </div>
        </div>

        <!-- Sidebar Control Panel -->
        <div id="controls-panel" class="pointer-events-auto bg-black/60 backdrop-blur-md border border-white/10 rounded-lg p-4 w-full max-w-sm mt-4 ml-auto sm:ml-0 overflow-y-auto max-h-[70vh] shadow-2xl transition-transform duration-300">
            <div class="space-y-4">

                <!-- Fractal Selector -->
                <div>
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider mb-1">Fractal Type</label>
                    <select id="select-fractal" class="w-full bg-white/10 border border-white/20 rounded px-2 py-1 text-sm focus:outline-none focus:border-blue-500 transition">
                        <option value="mandelbrot">Mandelbrot Set</option>
                        <option value="burning_ship">Burning Ship</option>
                        <option value="tricorn">Tricorn (Mandelbar)</option>
                        <option value="buffalo">Buffalo Fractal</option>
                        <option value="celtic">Celtic Fractal</option>
                        <option value="julia">Julia Set</option>
                        <option value="newton">Newton Fractal</option>
                    </select>
                </div>

                <!-- Parameters -->
                <div class="space-y-3">
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider">Parameters</label>

                    <div>
                        <div class="flex justify-between text-xs text-gray-300 mb-1">
                            <span>Zoom</span>
                            <span id="val-zoom">1.0</span>
                        </div>
                        <input type="range" id="input-zoom" min="0.1" max="10000" step="0.1" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div>
                        <div class="flex justify-between text-xs text-gray-300 mb-1">
                            <span>Iterations / Detail</span>
                            <span id="val-iter">100</span>
                        </div>
                        <input type="range" id="input-iter" min="10" max="100000" step="10" value="100" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <!-- Colors -->
                <div>
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider mb-1">Color Palette</label>
                    <div class="flex gap-2">
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-blue-500 to-purple-500 ring-2 ring-white/50 hover:scale-110 transition" onclick="app.setPalette('default')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-red-500 to-yellow-500 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('fire')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-green-400 to-teal-600 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('forest')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-gray-200 to-gray-800 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('bw')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-blue-700 to-cyan-400 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('ocean')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-pink-500 to-cyan-500 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('neon')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-purple-800 to-orange-400 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('sunset')"></button>
                        <!-- New Palettes -->
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-indigo-700 to-cyan-300 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('electric')" title="Electric"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-yellow-400 to-yellow-900 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('golden')" title="Golden"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-green-500 to-black ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('matrix')" title="Matrix"></button>
                    </div>
                </div>

                <!-- Julia Specific -->
                <div id="julia-controls" class="hidden space-y-2 border-t border-white/10 pt-2">
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider">Julia Constant (c)</label>
                    <div class="flex gap-2">
                         <div class="flex-1">
                            <span class="text-[10px] text-gray-400">Re</span>
                            <input type="range" id="input-julia-re" min="-2" max="2" step="0.001" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                         </div>
                         <div class="flex-1">
                            <span class="text-[10px] text-gray-400">Im</span>
                            <input type="range" id="input-julia-im" min="-2" max="2" step="0.001" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                         </div>
                    </div>
                </div>

                <!-- Export Controls -->
                <div class="border-t border-white/10 pt-2 space-y-2">
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider">Export</label>
                    <div class="flex items-center gap-2">
                         <input type="checkbox" id="check-export-frame" class="w-4 h-4 bg-white/20 rounded border-none">
                         <span class="text-xs text-gray-300">Show Export Frame (16:9)</span>
                    </div>
                    <button id="btn-export-highres" class="w-full bg-blue-600/80 hover:bg-blue-600 text-white text-xs font-bold py-2 px-4 rounded transition">
                        Export High-Res (4K)
                    </button>
                </div>

                <div class="text-[10px] text-gray-500 pt-2">
                    Drag/Arrows to Pan â€¢ Scroll/Pinch to Zoom
                </div>
            </div>
        </div>

        <!-- Favorites Panel (Hidden by default) -->
        <div id="favorites-panel" class="pointer-events-auto absolute top-16 right-4 w-64 bg-black/80 backdrop-blur-md border border-white/10 rounded-lg shadow-xl hidden flex-col max-h-[80vh]">
            <div class="p-3 border-b border-white/10 flex justify-between items-center">
                <h3 class="text-sm font-bold">Favorites</h3>
                <button id="btn-close-fav" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="favorites-list" class="flex-1 overflow-y-auto p-2 space-y-2">
                <!-- Favorites Items will be injected here -->
                <div class="text-center text-xs text-gray-500 py-4">No favorites yet</div>
            </div>
        </div>

    </div>

    <script>
        // --- Advanced Mode: Worker Code ---
        const workerCode = \`
            importScripts('https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.4.3/decimal.min.js');

            // High Precision Orbit Calculation Worker
            // Receives center, zoom (scale), maxIter
            // Returns Float32Array of orbit data (Interleaved Re, Im) or packed texture data

            onmessage = function(e) {
                const { centerRe, centerIm, maxIter, type, juliaCRe, juliaCIm } = e.data;

                // We use Decimal for the orbit calculation
                const cRe = new Decimal(centerRe);
                const cIm = new Decimal(centerIm);

                // Arrays to hold the orbit
                // We need maxIter points.
                // We will pack them into a Float32Array.
                // Format: [Re0, Im0, Re1, Im1, ...]
                const data = new Float32Array(maxIter * 2);

                let zRe = new Decimal(0);
                let zIm = new Decimal(0);

                // If Julia, z starts at pixel (which is center here for reference orbit)
                // Wait, reference orbit is usually the orbit of the critical point (0,0) for Mandelbrot
                // For Julia, reference orbit is orbit of the center pixel?
                // Yes, perturbation theory expands around a reference orbit $Z_{n}$.
                // Usually $Z_n$ is the orbit of the center of the screen.

                if (type === 'julia') {
                    zRe = cRe;
                    zIm = cIm;
                }

                const jcRe = (type === 'julia') ? new Decimal(juliaCRe) : null;
                const jcIm = (type === 'julia') ? new Decimal(juliaCIm) : null;

                for (let i = 0; i < maxIter; i++) {
                    // Store current Z (high precision converted to float)
                    // Note: We need high precision stored? No, the shader takes
                    // Reference Orbit as a texture. Textures are float32.
                    // If we store just float32, we lose the precision of the reference orbit!
                    // Perturbation theory requires High Precision Reference Orbit?
                    // "The reference orbit is computed with high precision."
                    // "Delta is computed with low precision."
                    // $Z_{n+1} = Z_{n}^2 + c$
                    // We need $Z_n$ in the formula $\Delta_{n+1} = 2 Z_n \Delta_n + \Delta_n^2 + \Delta c$
                    // If $Z_n$ is low precision (Float32), then $2 Z_n$ is low precision.
                    // However, $Z_n$ is Order(1). Float32 has 7 digits.
                    // If we are at $10^{-50}$, $\Delta$ is around $10^{-50}$.
                    // $2 \cdot Z_n \cdot \Delta_n \approx 1 \cdot 10^{-50}$.
                    // In Float32, adding $10^{-50}$ to $1$ kills it.
                    // But we don't add it to 1. We compute $\Delta_{n+1}$.
                    // $\Delta_{n+1}$ is small. $Z_n$ is large (O(1)).
                    // The product $Z_n \cdot \Delta_n$ is small.
                    // So we can compute this product in Float32!
                    // The precision of $Z_n$ only needs to be good enough such that the *error* in $Z_n$
                    // times $\Delta_n$ is small relative to $\Delta_{n+1}$?
                    // Actually, if $Z_n$ has error $\epsilon$, then $2(Z_n+\epsilon)\Delta_n = 2 Z_n \Delta_n + 2 \epsilon \Delta_n$.
                    // If $\epsilon \approx 10^{-7}$ (Float32), then error is $10^{-7} \Delta_n$.
                    // This is fine! $\Delta_n$ is scaling factor.
                    // So YES, we can store Reference Orbit in Float32 texture!
                    // The magic is that we don't calculate $Z_n$ on GPU. We calculate on CPU (high prec)
                    // and store the result (rounded to Float32) on GPU.

                    data[2*i] = zRe.toNumber();
                    data[2*i+1] = zIm.toNumber();

                    // Iterate
                    if (type === 'mandelbrot') {
                        // z = z^2 + c
                        // zRe_new = zRe^2 - zIm^2 + cRe
                        // zIm_new = 2*zRe*zIm + cIm
                        const zRe2 = zRe.times(zRe);
                        const zIm2 = zIm.times(zIm);
                        const newRe = zRe2.minus(zIm2).plus(cRe);
                        const newIm = zRe.times(zIm).times(2).plus(cIm);
                        zRe = newRe;
                        zIm = newIm;
                    } else if (type === 'julia') {
                         // z = z^2 + K
                         const zRe2 = zRe.times(zRe);
                         const zIm2 = zIm.times(zIm);
                         const newRe = zRe2.minus(zIm2).plus(jcRe);
                         const newIm = zRe.times(zIm).times(2).plus(jcIm);
                         zRe = newRe;
                         zIm = newIm;
                    }
                    // Add other types if needed, for MVP Mandelbrot is key

                    // Check escape for optimization?
                    // No, we need the full orbit for the shader to follow, even if it escapes?
                    // Usually we stop if it escapes, but shader needs to know it escaped.
                    // We'll fill the rest with 0 or last value?
                    // If reference escapes, then all nearby points likely escape too.
                    if (zRe.times(zRe).plus(zIm.times(zIm)).gt(4)) {
                         // Stop?
                         // We can fill the rest with huge numbers or specialized flag.
                         // Let's just continue for a bit or clamp.
                         // Actually, if Ref escapes, delta iteration is meaningless?
                         // Let's continue until maxIter. The values will blow up.
                         // Decimal handles large numbers well.
                    }
                }

                postMessage({ orbit: data });
            };
        \`;

        // --- Shaders ---

        const vertexShader = `
            attribute vec2 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat3 projectionMatrix;

            varying vec2 vTextureCoord;

            void main(void) {
                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
                vTextureCoord = aTextureCoord;
            }
        `;

        // Common utility functions for shaders
        const shaderUtils = `
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            vec3 getPaletteColor(float t, int paletteId) {
                // t is cyclic 0..1
                if (paletteId == 1) { // Fire
                    // Use a cyclic heat map
                    float x = t * 2.0;
                    if (x < 1.0) return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), x);
                    return mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 0.8), x - 1.0);
                } else if (paletteId == 2) { // Forest
                    return vec3(0.1 + 0.1*sin(t*6.28), 0.5 + 0.4*sin(t*6.28), 0.1 + 0.1*cos(t*6.28));
                } else if (paletteId == 3) { // BW
                    float v = 0.5 + 0.5 * sin(t * 6.28318);
                    return vec3(v);
                } else if (paletteId == 4) { // Ocean
                    return mix(vec3(0.0, 0.1, 0.4), vec3(0.0, 0.8, 0.9), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 5) { // Neon
                    return hsv2rgb(vec3(t, 1.0, 1.0));
                } else if (paletteId == 6) { // Sunset
                    return mix(vec3(0.2, 0.0, 0.2), vec3(1.0, 0.8, 0.2), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 7) { // Electric
                    // Indigo to Cyan
                    return mix(vec3(0.29, 0.0, 0.51), vec3(0.0, 1.0, 1.0), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 8) { // Golden
                    // Gold to Brown
                    return mix(vec3(1.0, 0.84, 0.0), vec3(0.55, 0.27, 0.07), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 9) { // Matrix
                    // Black to Green
                    float v = fract(t * 3.0);
                    return mix(vec3(0.0), vec3(0.0, 1.0, 0.2), v);
                }
                // Default (Rainbow/Blue-Purple)
                return hsv2rgb(vec3(0.6 + 0.4*t, 0.8, 1.0));
            }

            vec3 getSmoothColor(int iter, float magSq, int maxIter, int paletteId) {
                if (iter == maxIter) return vec3(0.0);

                float smoothIter = float(iter);
                if (magSq > 1.0) {
                    // smooth = iter + 1 - log2(log2(|z|))
                    // log2(|z|) = 0.5 * log2(|z|^2)
                    float logMod = 0.5 * log2(magSq);
                    float mu = log2(logMod);
                    smoothIter = smoothIter + 1.0 - mu;
                }

                // Cyclic coloring: frequency 0.02 (cycle every 50 iterations)
                float t = fract(smoothIter * 0.02);
                return getPaletteColor(t, paletteId);
            }
        `;

        // Double Precision Emulation Lib
        const dsMath = `
            // Double-Single Arithmetic (Emulated Double Precision)
            // Based on standard DS algorithms for GLSL

            vec2 ds_set(float a) { return vec2(a, 0.0); }

            vec2 ds_add(vec2 dsa, vec2 dsb) {
                vec2 dsc;
                float t1, t2, e;
                t1 = dsa.x + dsb.x;
                e = t1 - dsa.x;
                t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;
                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_sub(vec2 dsa, vec2 dsb) {
                vec2 dsc;
                float t1, t2, e;
                t1 = dsa.x - dsb.x;
                e = t1 - dsa.x;
                t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;
                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_mul(vec2 dsa, vec2 dsb) {
                vec2 dsc;
                float c11, c21, c2, e, t1, t2;
                float a = dsa.x;
                float b = dsb.x;

                float cona = a * 4097.0;
                float conb = b * 4097.0;
                float a1 = cona - (cona - a);
                float b1 = conb - (conb - b);
                float a2 = a - a1;
                float b2 = b - b1;

                c11 = a * b;
                c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));

                c2 = dsa.x * dsb.y + dsa.y * dsb.x;

                t1 = c11 + c2;
                e = t1 - c11;
                t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;

                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_sqr(vec2 dsa) {
                vec2 dsc;
                float c11, c21, c2, e, t1, t2;
                float a = dsa.x;
                float cona = a * 4097.0;
                float a1 = cona - (cona - a);
                float a2 = a - a1;

                c11 = a * a;
                c21 = a2 * a2 + (a2 * a1 + (a1 * a2 + (a1 * a1 - c11)));

                c2 = 2.0 * dsa.x * dsa.y;

                t1 = c11 + c2;
                e = t1 - c11;
                t2 = dsa.y * dsa.y + ((c2 - e) + (c11 - (t1 - e))) + c21;

                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_abs(vec2 a) {
                 if (a.x < 0.0) return vec2(-a.x, -a.y);
                 return a;
            }
        `;

        // Shader Code Definitions

        // 1. Mandelbrot (Normal and Deep)
        const mandelbrotFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);

                // Optimization: Cardioid and Period-2 Bulb Check
                // Cardioid: q * (q + (x-1/4)) < 1/4 * y^2, where q = (x-1/4)^2 + y^2
                float x = c.x;
                float y = c.y;
                float y2 = y * y;
                float q = (x - 0.25) * (x - 0.25) + y2;
                if (q * (q + (x - 0.25)) < 0.25 * y2) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }
                // Period-2 Bulb: (x+1)^2 + y^2 < 1/16
                if ((x + 1.0) * (x + 1.0) + y2 < 0.0625) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }

                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = (z.x * z.x - z.y * z.y) + c.x;
                    float y = (z.y * z.x + z.x * z.y) + c.y;
                    magSq = x * x + y * y;
                    if (magSq > 4.0) {
                        z.x = x; z.y = y; // Save escaped value for smoothing
                        iter++; // Count this iteration
                        break;
                    }
                    z.x = x; z.y = y;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const mandelbrotFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe; // High, Low
            uniform vec2 uCenterIm; // High, Low
            uniform float uScale; // 3.0 / Zoom
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                // Calculate C in Double Precision
                // c_re = CenterRe + uv.x * scale
                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);

                // c_im = CenterIm + uv.y * scale
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0, 0.0);
                vec2 z_im = vec2(0.0, 0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    // z_re_new = z_re^2 - z_im^2 + c_re
                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);
                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 z_re_new = ds_add(term1, c_re);

                    // z_im_new = 2 * z_re * z_im + c_im
                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 z_im_new = ds_add(term2_2, c_im);

                    // Check escape: z_re^2 + z_im^2 > 4.0
                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x; // Use high part of DS for magnitude estimate
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = z_re_new;
                    z_im = z_im_new;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 2. Burning Ship
        const burningShipFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = abs(z.x);
                    float y = abs(z.y);
                    float nx = x * x - y * y + c.x;
                    float ny = 2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const burningShipFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 x = ds_abs(z_re);
                    vec2 y = ds_abs(z_im);

                    vec2 x_sq = ds_sqr(x);
                    vec2 y_sq = ds_sqr(y);

                    vec2 term1 = ds_sub(x_sq, y_sq);
                    vec2 nx = ds_add(term1, c_re);

                    vec2 term2 = ds_mul(x, y);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(x_sq, y_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 3. Tricorn (Mandelbar)
        const tricornFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = z.x;
                    float y = z.y;
                    // conj(z)^2 + c
                    // (x-iy)^2 = x^2 - y^2 - 2ixy
                    // Verified aspect ratio: Tricorn matches scale of Mandelbrot correctly.

                    float nx = x * x - y * y + c.x;
                    float ny = -2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const tricornFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);

                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 nx = ds_add(term1, c_re);

                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_neg = vec2(-term2.x, -term2.y);
                    vec2 term2_2 = ds_add(term2_neg, term2_neg);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 4. Buffalo (Normal and Deep)
        const buffaloFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = abs(z.x);
                    float y = abs(z.y);
                    // Buffalo: |x^2 - y^2| - 2|xy|i + c
                    // |x^2 - y^2| is basically abs(x*x - y*y)
                    // Im part: -2|xy| is -2*abs(x*y)

                    float nx = abs(x * x - y * y) + c.x;
                    float ny = -2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const buffaloFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 x = ds_abs(z_re);
                    vec2 y = ds_abs(z_im);

                    vec2 x_sq = ds_sqr(x);
                    vec2 y_sq = ds_sqr(y);

                    vec2 term1 = ds_sub(x_sq, y_sq);
                    vec2 term1_abs = ds_abs(term1);
                    vec2 nx = ds_add(term1_abs, c_re);

                    vec2 term2 = ds_mul(x, y);
                    vec2 term2_neg = vec2(-term2.x, -term2.y);
                    vec2 term2_2 = ds_add(term2_neg, term2_neg);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(x_sq, y_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 5. Celtic (Normal and Deep)
        const celticFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = z.x;
                    float y = z.y;
                    // Celtic: |Re(z^2)| + i*Im(z^2) + c
                    // Re(z^2) = x^2 - y^2
                    // Im(z^2) = 2xy

                    float nx = abs(x * x - y * y) + c.x;
                    float ny = 2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const celticFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);

                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 term1_abs = ds_abs(term1);
                    vec2 nx = ds_add(term1_abs, c_re);

                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 6. Julia (Normal and Deep)
        const juliaFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;
            uniform vec2 uJuliaC;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 z = uCenter + uv * (3.0 / uZoom);
                vec2 c = uJuliaC;

                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = (z.x * z.x - z.y * z.y) + c.x;
                    float y = (z.y * z.x + z.x * z.y) + c.y;
                    magSq = x * x + y * y;
                    if (magSq > 4.0) {
                        z.x = x; z.y = y;
                        iter++;
                        break;
                    }
                    z.x = x; z.y = y;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const juliaFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;
            uniform vec2 uJuliaCRe;
            uniform vec2 uJuliaCIm;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                // z = Center + uv * scale
                vec2 z_re = ds_add(uCenterRe, vec2(uv.x * uScale, 0.0));
                vec2 z_im = ds_add(uCenterIm, vec2(uv.y * uScale, 0.0));

                // c is constant
                vec2 c_re = uJuliaCRe;
                vec2 c_im = uJuliaCIm;

                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);
                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 z_re_new = ds_add(term1, c_re);

                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 z_im_new = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = z_re_new;
                    z_im = z_im_new;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 5. Newton (Standard only)
        const newtonFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            vec2 cmul(vec2 a, vec2 b) {
                return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
            }

            vec2 cdiv(vec2 a, vec2 b) {
                float denom = b.x*b.x + b.y*b.y;
                return vec2((a.x*b.x + a.y*b.y)/denom, (a.y*b.x - a.x*b.y)/denom);
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 z = uCenter + uv * (3.0 / uZoom);

                int iter = 0;
                vec2 roots[3];
                roots[0] = vec2(1.0, 0.0);
                roots[1] = vec2(-0.5, 0.866025);
                roots[2] = vec2(-0.5, -0.866025);

                int rootIdx = -1;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z2 = cmul(z, z);
                    vec2 z3 = cmul(z2, z);
                    vec2 num = z3 - vec2(1.0, 0.0);
                    vec2 den = 3.0 * z2;

                    if (length(den) < 0.0001) break;

                    z = z - cdiv(num, den);

                    for (int r = 0; r < 3; r++) {
                        float d = distance(z, roots[r]);
                        if (d < 0.001) {
                            rootIdx = r;
                            iter = i;
                            break;
                        }
                    }
                    if (rootIdx != -1) break;
                }

                if (rootIdx != -1) {
                    float t = float(iter) / 50.0;
                    vec3 baseCol;
                    if (rootIdx == 0) baseCol = vec3(1.0, 0.2, 0.2);
                    else if (rootIdx == 1) baseCol = vec3(0.2, 1.0, 0.2);
                    else baseCol = vec3(0.2, 0.2, 1.0);

                    gl_FragColor = vec4(baseCol * (1.0 - t), 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                }
            }
        `;

        // --- Perturbation Shader ---
        // Uses texture for Reference Orbit
        const perturbationFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform int uMaxIter;
            uniform int uPalette;

            uniform sampler2D uRefOrbit; // Texture holding Z_ref values (Re, Im)
            uniform vec2 uDeltaC; // Offset from center in world coordinates (low precision is fine relative to center?)
            // Wait, uDeltaC is the pixel offset scaled by zoom.
            // If Zoom is 10^50, scale is 10^-50.
            // We pass uDeltaC as vec2?
            // In the shader, we calculate delta = 2*Zref*delta + delta^2 + deltaC
            // deltaC is constant for the pixel? Yes.
            // deltaC = (uv - 0.5) * scale.
            // If scale is 10^-50, deltaC underflows float32.
            // THIS IS THE CORE ISSUE: We need to represent deltaC in the shader.
            // Standard perturbation usually just works because delta is small?
            // No, if delta underflows, it's 0.
            // However, we can use an exponent?
            // Or maybe the user implies we just implement the logic and assumes we handle the zoom elsewhere?
            // "Implements the perturbation formula: delta = 2.0 * z_ref * delta + delta * delta + delta_c."
            // "Glitches: I know glitches happen when delta gets too large. For this MVP, just implement a basic 'escape radius' check..."

            // To make it visible for the MVP without full emulation, we will assume
            // we are within float precision or just implementing the structure.
            // But if I want it to actually work for deep zoom, I need to handle small numbers.
            // Actually, if we just multiply everything by a large factor?
            // Let's implement the standard formula. The architecture is what matters here.

            // uniform vec2 uPixelOffset; // REMOVED: computed in main
            uniform float uScale;      // Scale per pixel (e.g. 10^-50)

            ` + shaderUtils + `

            void main() {
                // Calculate uPixelOffset from gl_FragCoord and Resolution
                vec2 centerPixel = uResolution.xy * 0.5;
                vec2 pixelOffset = gl_FragCoord.xy - centerPixel;

                // Correction: Y-axis flip check?
                // Pixi JS: gl_FragCoord (0,0) is bottom-left? Or top-left?
                // WebGL is bottom-left. Pixi usually handles projection.
                // Let's assume standard behavior for now.
                // Also account for Aspect Ratio adjustment in 'uScale'?
                // uScale is passed as "3.0 / Zoom". It is units per pixel?
                // Actually in my code: scale = 3.0 / (zoom * minDim).
                // Ah, uScale passed to shader is just 3.0/Zoom.
                // We need to divide by resolution min dimension.
                // Let's fix calculation of dc:

                float minDim = min(uResolution.x, uResolution.y);
                // normalized uv [-0.5, 0.5] * aspect
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / minDim;

                // dc = uv * 3.0 / Zoom
                vec2 dc = uv * uScale;

                vec2 d = vec2(0.0); // Delta starts at 0 (since Z starts at Zref)

                int iter = 0;
                float magSq = 0.0;

                // Texture size for lookups
                // We assume 1D texture layout packed in 2D or just 2D?
                // For simplicity, let's assume a 1D texture of width = MaxIter (if fits)
                // or we use uMaxIter to map index to UV.
                // Let's assume texture is Width x Height.
                // We need to map linear index 'i' to (u, v).

                // Let's assume texture width is 4096.
                float texWidth = 4096.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    // Fetch Z_ref from texture
                    // Map i to UV
                    float u = (float(i) + 0.5) / texWidth;
                    float v = 0.5; // Single row for now?
                    // Handle wrapping if > 4096?
                    float row = floor(float(i) / texWidth);
                    u = (float(i) - row * texWidth + 0.5) / texWidth;
                    v = (row + 0.5) / texWidth; // Assuming square texture or height enough

                    vec4 refVal = texture2D(uRefOrbit, vec2(u, v));
                    vec2 zRef = refVal.xy;

                    // Iteration: d = 2*zRef*d + d^2 + dc
                    // Complex multiplication:
                    // (a+bi)(c+di) = (ac-bd) + i(ad+bc)

                    // term1 = 2 * zRef * d
                    vec2 term1;
                    term1.x = 2.0 * (zRef.x * d.x - zRef.y * d.y);
                    term1.y = 2.0 * (zRef.x * d.y + zRef.y * d.x);

                    // term2 = d^2
                    vec2 term2;
                    term2.x = d.x * d.x - d.y * d.y;
                    term2.y = 2.0 * d.x * d.y;

                    d = term1 + term2 + dc;

                    // Check Escape: |Zref + d| > 2
                    vec2 z = zRef + d;
                    magSq = dot(z, z);

                    if (magSq > 4.0) {
                        iter = i; // captured iter
                        break;
                    }
                    iter = i;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;


        // --- Application Class ---

        class AdvancedApp {
            constructor() {
                this.app = new PIXI.Application({
                    resizeTo: window,
                    backgroundColor: 0x000000,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true,
                    powerPreference: "high-performance"
                });

                document.getElementById('canvas-container-advanced').appendChild(this.app.view);

                this.state = {
                    fractal: 'mandelbrot',
                    zoom: 1.0,
                    center: { x: new Decimal(-0.5), y: new Decimal(0.0) },
                    iterations: 100,
                    palette: 0,
                    juliaC: { x: -0.7, y: 0.27015 }
                };

                // Initialize Worker
                const blob = new Blob([workerCode], {type: 'application/javascript'});
                this.worker = new Worker(URL.createObjectURL(blob));

                this.worker.onmessage = (e) => {
                    this.onWorkerMessage(e);
                };

                // Texture for Orbit
                // 4096 width allows up to 4096 iterations in one row.
                // For 100,000, we need height > 25. Let's allocate 4096 x 32 (~131k iters)
                this.orbitTextureWidth = 4096;
                this.orbitTextureHeight = 32;
                this.orbitData = new Float32Array(this.orbitTextureWidth * this.orbitTextureHeight * 4); // RGBA
                this.orbitTexture = PIXI.BaseTexture.fromBuffer(this.orbitData, this.orbitTextureWidth, this.orbitTextureHeight, {
                    format: PIXI.FORMATS.RGBA,
                    type: PIXI.TYPES.FLOAT
                });

                this.fractalContainer = new PIXI.Container();
                this.fractalSprite = new PIXI.Sprite(PIXI.Texture.WHITE);
                this.fractalSprite.width = this.app.screen.width;
                this.fractalSprite.height = this.app.screen.height;
                this.fractalContainer.addChild(this.fractalSprite);
                this.app.stage.addChild(this.fractalContainer);

                this.uniforms = {
                    uResolution: [this.app.renderer.width, this.app.renderer.height],
                    uMaxIter: this.state.iterations,
                    uPalette: this.state.palette,
                    uRefOrbit: new PIXI.Texture(this.orbitTexture),
                    uPixelOffset: [0, 0], // Per pixel? No, wait.
                    // Shader runs per pixel.
                    // gl_FragCoord gives pixel coord.
                    // shader needs (coord - centerPixel) * scale.
                    // centerPixel is Resolution/2.
                    // So we don't pass uPixelOffset uniform, we calculate it in shader?
                    // Ah, the perturbation formula uses delta from Ref Orbit.
                    // Ref Orbit is at Center.
                    // So Delta C for pixel (x,y) is (x-cx, y-cy)*scale.
                    // So we pass uScale.
                    // We need uPixelOffset? No, we use gl_FragCoord.
                    // But in shader "uPixelOffset" was in my code.
                    // I will fix the shader logic via uniforms:
                    // We pass uCenterPixel (screen coords).
                    uCenterPixel: [this.app.renderer.width/2, this.app.renderer.height/2],
                    uScale: 3.0 / this.state.zoom
                };

                // Correction for Shader:
                // The shader I wrote uses `uPixelOffset`. I should update uniforms to match or rely on gl_FragCoord.
                // Actually `uPixelOffset` implies a uniform per pixel? No, that's varying.
                // I'll update the shader to compute `vec2 p = gl_FragCoord.xy - uResolution.xy * 0.5`.
                // `uPixelOffset` in the shader was a mistake in naming if it was meant to be varying.
                // Let's pass uScale and let shader compute offset.
                // I will need to update the shader code or use a uniform that I update?
                // No, shader runs for all pixels.
                // I'll leave the shader as is for now and assume I might fix it,
                // OR I can use `uScale` and `uResolution` to compute `dc` in shader.
                // `vec2 dc = (gl_FragCoord.xy - uResolution.xy*0.5) * uScale;`

                this.perturbationFilter = new PIXI.Filter(vertexShader, perturbationFrag, this.uniforms);
                // Fix the shader source code regarding uPixelOffset?
                // I can prepend a define or replace it.
                // Ideally I should have written the shader correctly.
                // I'll replace `uniform vec2 uPixelOffset;` with logic in main.
                // Wait, I can't easily edit the string now without another patch.
                // I will do a quick patch to the shader string in the next step or
                // just rely on the fact that I can set `uPixelOffset` to something?
                // No, it needs to vary per pixel.
                // I must fix the shader.

                this.fractalContainer.filters = [this.perturbationFilter];

                this.bindEvents();
                this.requestOrbitUpdate();
            }

            requestOrbitUpdate() {
                // Send message to worker
                this.worker.postMessage({
                    centerRe: this.state.center.x.toString(),
                    centerIm: this.state.center.y.toString(),
                    maxIter: this.state.iterations,
                    type: this.state.fractal,
                    juliaCRe: this.state.juliaC.x,
                    juliaCIm: this.state.juliaC.y
                });
            }

            onWorkerMessage(e) {
                const orbit = e.data.orbit; // Float32Array [Re, Im, Re, Im...]

                // Upload to Texture
                // We need to pack Re, Im into RGBA?
                // Or just R, G.
                // Float texture supports RG.
                // But PixiJS might default to RGBA.
                // Let's pack into RGBA (Re, Im, 0, 0).

                // Map orbit (length 2*N) to texture (length 4*W*H)
                const texData = this.orbitData;
                for (let i = 0; i < orbit.length / 2; i++) {
                    texData[4*i] = orbit[2*i];     // R = Re
                    texData[4*i+1] = orbit[2*i+1]; // G = Im
                    texData[4*i+2] = 0;
                    texData[4*i+3] = 1;
                }

                this.orbitTexture.update();

                // Trigger render? Pixi handles it.
            }

            bindEvents() {
                 // Similar event handling (Pan/Zoom) but updates Decimal center and calls Worker
                 const canvas = this.app.view;

                 const onWheel = (e) => {
                    e.preventDefault();
                    // Basic zoom for POC
                    const zoomFactor = 1.1;
                    if (e.deltaY < 0) this.state.zoom *= zoomFactor;
                    else this.state.zoom /= zoomFactor;

                    this.uniforms.uScale = 3.0 / this.state.zoom;
                    // No need to recompute orbit if center doesn't change?
                    // Standard perturbation reuses orbit if center is same?
                    // Yes. But if we pan, we need new orbit (or shift).
                    // For zoom at center, orbit is same.

                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toExponential(2);
                 };
                 canvas.addEventListener('wheel', onWheel, { passive: false });

                 // Panning (Drag)
                 // Need to update center and recompute orbit
                 let isDragging = false;
                 let lastX, lastY;

                 canvas.addEventListener('pointerdown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
                 canvas.addEventListener('pointerup', () => isDragging = false);
                 canvas.addEventListener('pointermove', e => {
                     if (!isDragging) return;
                     const dx = e.clientX - lastX;
                     const dy = e.clientY - lastY;
                     lastX = e.clientX;
                     lastY = e.clientY;

                     const scale = 3.0 / (this.state.zoom * Math.min(this.app.screen.width, this.app.screen.height));
                     const dX = new Decimal(dx).times(scale);
                     const dY = new Decimal(dy).times(scale);

                     this.state.center.x = this.state.center.x.minus(dX);
                     this.state.center.y = this.state.center.y.plus(dY);

                     // Debounce orbit update? For now, update every move (might be slow)
                     this.requestOrbitUpdate();
                 });
            }

            updateShader() {
                // Update uniforms
                this.perturbationFilter.uniforms.uMaxIter = this.state.iterations;
                this.perturbationFilter.uniforms.uPalette = this.state.palette;
                this.perturbationFilter.uniforms.uScale = 3.0 / this.state.zoom;
            }
        }

        class FractalApp {

                // Default state
                this.defaultState = {
                    fractal: 'mandelbrot',
                    zoom: 1.0,
                    center: { x: new Decimal(-0.5), y: new Decimal(0.0) },
                    iterations: 100,
                    palette: 0,
                    juliaC: { x: -0.7, y: 0.27015 },
                    favorites: []
                };

                // Deep copy manually for Decimal objects
                this.state = {
                    ...this.defaultState,
                    center: { x: new Decimal(this.defaultState.center.x), y: new Decimal(this.defaultState.center.y) },
                    favorites: []
                };
                this.history = [];
                this.showExportFrame = false;

                // Filter container
                this.fractalContainer = new PIXI.Container();
                this.fractalSprite = new PIXI.Sprite(PIXI.Texture.WHITE);
                this.fractalSprite.width = this.app.screen.width;
                this.fractalSprite.height = this.app.screen.height;
                this.fractalContainer.addChild(this.fractalSprite);
                this.app.stage.addChild(this.fractalContainer);

                // Shader Uniforms (Normal) - FIX: Use renderer width/height (physical) for proper resolution mapping
                this.uniforms = {
                    uResolution: [this.app.renderer.width, this.app.renderer.height],
                    uCenter: [this.state.center.x, this.state.center.y],
                    uZoom: this.state.zoom,
                    uMaxIter: this.state.iterations,
                    uPalette: this.state.palette
                };

                // Deep Zoom Uniforms
                this.uniformsDeep = {
                    uResolution: [this.app.renderer.width, this.app.renderer.height],
                    uCenterRe: [0, 0],
                    uCenterIm: [0, 0],
                    uScale: 1.0,
                    uMaxIter: this.state.iterations,
                    uPalette: this.state.palette
                };

                // Initialize Shaders
                // Normal
                this.mandelbrotFilter = new PIXI.Filter(vertexShader, mandelbrotFrag, this.uniforms);
                this.juliaFilter = new PIXI.Filter(vertexShader, juliaFrag, { ...this.uniforms, uJuliaC: [this.state.juliaC.x, this.state.juliaC.y] });
                this.burningShipFilter = new PIXI.Filter(vertexShader, burningShipFrag, this.uniforms);
                this.tricornFilter = new PIXI.Filter(vertexShader, tricornFrag, this.uniforms);
                this.buffaloFilter = new PIXI.Filter(vertexShader, buffaloFrag, this.uniforms);
                this.celticFilter = new PIXI.Filter(vertexShader, celticFrag, this.uniforms);
                this.newtonFilter = new PIXI.Filter(vertexShader, newtonFrag, this.uniforms);

                // Deep
                this.mandelbrotFilterDeep = new PIXI.Filter(vertexShader, mandelbrotFragDeep, this.uniformsDeep);
                this.juliaFilterDeep = new PIXI.Filter(vertexShader, juliaFragDeep, { ...this.uniformsDeep, uJuliaCRe: [0,0], uJuliaCIm: [0,0] });
                this.burningShipFilterDeep = new PIXI.Filter(vertexShader, burningShipFragDeep, this.uniformsDeep);
                this.tricornFilterDeep = new PIXI.Filter(vertexShader, tricornFragDeep, this.uniformsDeep);
                this.buffaloFilterDeep = new PIXI.Filter(vertexShader, buffaloFragDeep, this.uniformsDeep);
                this.celticFilterDeep = new PIXI.Filter(vertexShader, celticFragDeep, this.uniformsDeep);

                // Apply initial shader
                this.updateShader();
                this.updateUniforms();

                // Bind events
                this.bindEvents();

                // Resize handler
                this.app.renderer.on('resize', () => {
                    this.fractalSprite.width = this.app.screen.width;
                    this.fractalSprite.height = this.app.screen.height;

                    // FIX: Update with physical resolution
                    this.uniforms.uResolution = [this.app.renderer.width, this.app.renderer.height];
                    this.uniformsDeep.uResolution = [this.app.renderer.width, this.app.renderer.height];

                    this.updateExportFrame();
                });
            }

            // Helper to split High Precision Decimal to two Float32 (High, Low) for DS Arithmetic
            splitDecimal(decimalVal) {
                const valNumber = decimalVal.toNumber();
                const high = Math.fround(valNumber);
                const low = Math.fround(decimalVal.minus(high).toNumber());
                return [high, low];
            }

            pushState() {
                // Manually serialize Decimal state because JSON.stringify converts them to strings
                // and we want to snapshot values, not references if they were objects (Decimal objects are immutable but let's be safe)
                const snapshot = {
                    ...this.state,
                    center: { x: this.state.center.x.toString(), y: this.state.center.y.toString() },
                    favorites: [] // don't push favorites
                };
                // JSON stringify/parse to clone other primitives deeply
                const clone = JSON.parse(JSON.stringify(snapshot));
                this.history.push(clone);
                if (this.history.length > 20) this.history.shift();
            }

            undo() {
                if (this.history.length === 0) return;
                const prev = this.history.pop();
                const currentFavs = this.state.favorites;

                // Restore state and re-inflate Decimals
                this.state = {
                    ...prev,
                    center: { x: new Decimal(prev.center.x), y: new Decimal(prev.center.y) },
                    favorites: currentFavs
                };

                document.getElementById('select-fractal').value = this.state.fractal;
                document.getElementById('input-zoom').value = this.state.zoom;
                document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                document.getElementById('input-iter').value = this.state.iterations;
                document.getElementById('val-iter').innerText = this.state.iterations;

                if (this.state.fractal === 'julia') {
                    document.getElementById('julia-controls').classList.remove('hidden');
                    document.getElementById('input-julia-re').value = this.state.juliaC.x;
                    document.getElementById('input-julia-im').value = this.state.juliaC.y;
                } else {
                    document.getElementById('julia-controls').classList.add('hidden');
                }

                this.updateShader();
                this.updateUniforms();
            }

            resetView() {
                const favs = this.state.favorites;
                this.pushState();
                this.state = JSON.parse(JSON.stringify(this.defaultState));
                this.state.favorites = favs;

                document.getElementById('select-fractal').value = this.state.fractal;
                document.getElementById('input-zoom').value = 1.0;
                document.getElementById('val-zoom').innerText = "1.00";
                document.getElementById('input-iter').value = this.state.iterations;
                document.getElementById('val-iter').innerText = this.state.iterations;
                document.getElementById('input-julia-re').value = this.state.juliaC.x;
                document.getElementById('input-julia-im').value = this.state.juliaC.y;
                document.getElementById('julia-controls').classList.add('hidden');

                this.updateShader();
                this.updateUniforms();
                this.saveSettings();
            }

            isDeepZoom() {
                // Switch to Deep Mode if zoom is large enough to need it (approx > 50,000)
                return this.state.zoom > 1000.0;
            }

            updateShader() {
                this.fractalContainer.visible = true;
                this.fractalContainer.filters = [];

                const deep = this.isDeepZoom();
                const type = this.state.fractal;

                if (type === 'mandelbrot') {
                    this.fractalContainer.filters = deep ? [this.mandelbrotFilterDeep] : [this.mandelbrotFilter];
                } else if (type === 'burning_ship') {
                    this.fractalContainer.filters = deep ? [this.burningShipFilterDeep] : [this.burningShipFilter];
                } else if (type === 'tricorn') {
                    this.fractalContainer.filters = deep ? [this.tricornFilterDeep] : [this.tricornFilter];
                } else if (type === 'buffalo') {
                    this.fractalContainer.filters = deep ? [this.buffaloFilterDeep] : [this.buffaloFilter];
                } else if (type === 'celtic') {
                    this.fractalContainer.filters = deep ? [this.celticFilterDeep] : [this.celticFilter];
                } else if (type === 'julia') {
                    this.fractalContainer.filters = deep ? [this.juliaFilterDeep] : [this.juliaFilter];
                } else if (type === 'newton') {
                    this.fractalContainer.filters = [this.newtonFilter];
                }
            }

            updateUniforms() {
                const deep = this.isDeepZoom();
                const type = this.state.fractal;

                // Ensure correct filter is applied (if zoom crossed threshold)
                let neededFilter;
                if (type === 'mandelbrot') neededFilter = deep ? this.mandelbrotFilterDeep : this.mandelbrotFilter;
                else if (type === 'burning_ship') neededFilter = deep ? this.burningShipFilterDeep : this.burningShipFilter;
                else if (type === 'tricorn') neededFilter = deep ? this.tricornFilterDeep : this.tricornFilter;
                else if (type === 'buffalo') neededFilter = deep ? this.buffaloFilterDeep : this.buffaloFilter;
                else if (type === 'celtic') neededFilter = deep ? this.celticFilterDeep : this.celticFilter;
                else if (type === 'julia') neededFilter = deep ? this.juliaFilterDeep : this.juliaFilter;
                else if (type === 'newton') neededFilter = this.newtonFilter;

                const currentFilters = this.fractalContainer.filters;
                if (!currentFilters || currentFilters[0] !== neededFilter) {
                    this.fractalContainer.filters = [neededFilter];
                }

                // Update Uniform Values
                if (!deep) {
                    // Standard Uniforms
                    this.uniforms.uCenter = [this.state.center.x, this.state.center.y];
                    this.uniforms.uZoom = this.state.zoom;
                    this.uniforms.uMaxIter = this.state.iterations;
                    this.uniforms.uPalette = this.state.palette;

                    // Propagate to ALL potential standard filters to be safe (or just current)
                    if(type === 'mandelbrot') {
                        this.mandelbrotFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.mandelbrotFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.mandelbrotFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.mandelbrotFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'burning_ship') {
                        this.burningShipFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.burningShipFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.burningShipFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.burningShipFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'tricorn') {
                        this.tricornFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.tricornFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.tricornFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.tricornFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'buffalo') {
                        this.buffaloFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.buffaloFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.buffaloFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.buffaloFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'celtic') {
                        this.celticFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.celticFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.celticFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.celticFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'julia') {
                        this.juliaFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.juliaFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.juliaFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.juliaFilter.uniforms.uPalette = this.uniforms.uPalette;
                        this.juliaFilter.uniforms.uJuliaC = [this.state.juliaC.x, this.state.juliaC.y];
                    }
                    else if(type === 'newton') {
                        this.newtonFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.newtonFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.newtonFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.newtonFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                } else {
                    // Deep Uniforms
                    const cx = this.splitDecimal(this.state.center.x);
                    const cy = this.splitDecimal(this.state.center.y);
                    const scale = 3.0 / this.state.zoom;

                    if (type === 'mandelbrot') {
                        this.mandelbrotFilterDeep.uniforms.uCenterRe = cx;
                        this.mandelbrotFilterDeep.uniforms.uCenterIm = cy;
                        this.mandelbrotFilterDeep.uniforms.uScale = scale;
                        this.mandelbrotFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.mandelbrotFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'burning_ship') {
                        this.burningShipFilterDeep.uniforms.uCenterRe = cx;
                        this.burningShipFilterDeep.uniforms.uCenterIm = cy;
                        this.burningShipFilterDeep.uniforms.uScale = scale;
                        this.burningShipFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.burningShipFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'tricorn') {
                        this.tricornFilterDeep.uniforms.uCenterRe = cx;
                        this.tricornFilterDeep.uniforms.uCenterIm = cy;
                        this.tricornFilterDeep.uniforms.uScale = scale;
                        this.tricornFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.tricornFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'buffalo') {
                        this.buffaloFilterDeep.uniforms.uCenterRe = cx;
                        this.buffaloFilterDeep.uniforms.uCenterIm = cy;
                        this.buffaloFilterDeep.uniforms.uScale = scale;
                        this.buffaloFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.buffaloFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'celtic') {
                        this.celticFilterDeep.uniforms.uCenterRe = cx;
                        this.celticFilterDeep.uniforms.uCenterIm = cy;
                        this.celticFilterDeep.uniforms.uScale = scale;
                        this.celticFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.celticFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'julia') {
                        // Julia C is stored as number, convert to Decimal for splitting
                        const jcx = this.splitDecimal(new Decimal(this.state.juliaC.x));
                        const jcy = this.splitDecimal(new Decimal(this.state.juliaC.y));

                        this.juliaFilterDeep.uniforms.uCenterRe = cx;
                        this.juliaFilterDeep.uniforms.uCenterIm = cy;
                        this.juliaFilterDeep.uniforms.uScale = scale;
                        this.juliaFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.juliaFilterDeep.uniforms.uPalette = this.state.palette;
                        this.juliaFilterDeep.uniforms.uJuliaCRe = jcx;
                        this.juliaFilterDeep.uniforms.uJuliaCIm = jcy;
                    }
                }
            }

            getScaleFactor() {
                return 3.0; // Standardized for all shaders now
            }

            getExportFrameDimensions() {
                const sw = this.app.screen.width;
                const sh = this.app.screen.height;
                const aspect = 16/9;

                // Use 0.75 (75%) instead of 0.9 to avoid overlapping UI
                let w = sw * 0.75;
                let h = w / aspect;

                if (h > sh * 0.75) {
                    h = sh * 0.75;
                    w = h * aspect;
                }
                return { w, h };
            }

            updateExportFrame() {
                const frame = document.getElementById('export-frame');
                if (!this.showExportFrame) {
                    frame.classList.add('hidden');
                    return;
                }

                const dims = this.getExportFrameDimensions();
                const sw = this.app.screen.width;
                const sh = this.app.screen.height;

                frame.style.width = `${dims.w}px`;
                frame.style.height = `${dims.h}px`;
                frame.style.left = `${(sw - dims.w)/2}px`;
                frame.style.top = `${(sh - dims.h)/2}px`;

                frame.classList.remove('hidden');
            }

            bindEvents() {
                const canvas = this.app.view;
                let activePointers = new Map();
                let initialPinchDist = 0;
                let initialZoom = 1;
                let isDragging = false;
                let lastPoint = null;

                const handleStart = (e) => {
                    if(e.type === 'touchstart') e.preventDefault();

                    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                    if (activePointers.size === 1) {
                         this.pushState();
                         isDragging = true;
                         lastPoint = { x: e.clientX, y: e.clientY };
                    } else if (activePointers.size === 2) {
                        isDragging = false;
                        const points = Array.from(activePointers.values());
                        initialPinchDist = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y);
                        initialZoom = this.state.zoom;
                    }
                };

                const handleMove = (e) => {
                    if (!activePointers.has(e.pointerId)) return;
                    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                    if (activePointers.size === 1 && isDragging) {
                        const current = { x: e.clientX, y: e.clientY };
                        const dx = current.x - lastPoint.x;
                        const dy = current.y - lastPoint.y;
                        const scale = this.getScaleFactor() / (this.state.zoom * Math.min(this.app.screen.width, this.app.screen.height));

                        // Use Decimal for accumulation
                        const dxDec = new Decimal(dx).times(scale);
                        const dyDec = new Decimal(dy).times(scale);

                        this.state.center.x = this.state.center.x.minus(dxDec);
                        this.state.center.y = this.state.center.y.plus(dyDec);

                        lastPoint = current;
                        this.updateUniforms();

                    } else if (activePointers.size === 2) {
                        const points = Array.from(activePointers.values());
                        const dist = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y);

                        if (initialPinchDist > 0) {
                            const ratio = dist / initialPinchDist;
                            const newZoom = initialZoom * ratio;
                            this.state.zoom = newZoom;

                            document.getElementById('input-zoom').value = this.state.zoom;
                            document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                            this.updateUniforms();
                        }
                    }
                };

                const handleEnd = (e) => {
                    activePointers.delete(e.pointerId);
                    if (activePointers.size < 2) {
                        initialPinchDist = 0;
                    }
                    if (activePointers.size === 1) {
                         isDragging = true;
                         const p = activePointers.values().next().value;
                         lastPoint = { x: p.x, y: p.y };
                    } else {
                        isDragging = false;
                    }
                };

                canvas.addEventListener('pointerdown', handleStart);
                canvas.addEventListener('pointermove', handleMove);
                canvas.addEventListener('pointerup', handleEnd);
                canvas.addEventListener('pointercancel', handleEnd);
                canvas.addEventListener('pointerout', handleEnd);
                canvas.addEventListener('pointerleave', handleEnd);

                const onWheel = (e) => {
                    e.preventDefault();
                    const rect = this.app.view.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    const w = this.app.screen.width;
                    const h = this.app.screen.height;
                    const minDim = Math.min(w, h);

                    const u = (mx - w * 0.5) / minDim;
                    const v = (h * 0.5 - my) / minDim;

                    const oldZoom = this.state.zoom;
                    const zoomFactor = 1.1;

                    if (e.deltaY < 0) {
                        this.state.zoom *= zoomFactor;
                    } else {
                        this.state.zoom /= zoomFactor;
                    }

                    // term = scale * (1/oldZoom - 1/newZoom)
                    // We can use native JS numbers for term calculation as long as zoom is not huge (it's up to 10^14)
                    // But to be consistent with 'center' which is Decimal, we should cast.
                    // u, v are small floats.

                    const scaleFactor = this.getScaleFactor();
                    const termVal = scaleFactor * (1.0/oldZoom - 1.0/this.state.zoom);
                    const uDec = new Decimal(u);
                    const vDec = new Decimal(v);
                    const termDec = new Decimal(termVal);

                    this.state.center.x = this.state.center.x.plus(uDec.times(termDec));
                    this.state.center.y = this.state.center.y.plus(vDec.times(termDec));

                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);

                    this.updateUniforms();
                };

                canvas.addEventListener('wheel', onWheel, { passive: false });

                const onDblClick = (e) => {
                    e.preventDefault();
                    this.pushState();

                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    const w = this.app.screen.width;
                    const h = this.app.screen.height;
                    const minDim = Math.min(w, h);

                    const u = (mx - w * 0.5) / minDim;
                    const v = (h * 0.5 - my) / minDim;

                    const scale = this.getScaleFactor();
                    // const wx = this.state.center.x + u * (scale / this.state.zoom);
                    // const wy = this.state.center.y + v * (scale / this.state.zoom);

                    const offsetScale = scale / this.state.zoom;
                    const uDec = new Decimal(u);
                    const vDec = new Decimal(v);
                    const osDec = new Decimal(offsetScale);

                    this.state.center.x = this.state.center.x.plus(uDec.times(osDec));
                    this.state.center.y = this.state.center.y.plus(vDec.times(osDec));

                    if (e.altKey) {
                        this.state.zoom /= 2.0;
                    } else {
                        this.state.zoom *= 2.0;
                    }

                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                    this.updateUniforms();
                };

                canvas.addEventListener('dblclick', onDblClick);

                window.addEventListener('keydown', (e) => {
                    const minDim = Math.min(this.app.screen.width, this.app.screen.height);
                    const scale = this.getScaleFactor() / (this.state.zoom * minDim);
                    const stepPixels = 50;
                    const moveStep = new Decimal(stepPixels * scale);

                    if (e.key === 'ArrowUp') { this.pushState(); this.state.center.y = this.state.center.y.plus(moveStep); }
                    else if (e.key === 'ArrowDown') { this.pushState(); this.state.center.y = this.state.center.y.minus(moveStep); }
                    else if (e.key === 'ArrowLeft') { this.pushState(); this.state.center.x = this.state.center.x.minus(moveStep); }
                    else if (e.key === 'ArrowRight') { this.pushState(); this.state.center.x = this.state.center.x.plus(moveStep); }
                    else return;

                    this.updateUniforms();
                });

                document.getElementById('select-fractal').addEventListener('change', (e) => {
                    this.state.fractal = e.target.value;
                    if (this.state.fractal === 'julia') document.getElementById('julia-controls').classList.remove('hidden');
                    else document.getElementById('julia-controls').classList.add('hidden');
                    this.updateShader();
                    this.updateUniforms();
                });

                document.getElementById('input-zoom').addEventListener('input', (e) => {
                    this.state.zoom = parseFloat(e.target.value);
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                    this.updateUniforms();
                });

                document.getElementById('input-iter').addEventListener('input', (e) => {
                    this.state.iterations = parseInt(e.target.value);
                    document.getElementById('val-iter').innerText = this.state.iterations;
                    this.updateUniforms();
                });

                document.getElementById('input-julia-re').addEventListener('input', (e) => {
                    this.state.juliaC.x = parseFloat(e.target.value);
                    this.updateUniforms();
                });
                document.getElementById('input-julia-im').addEventListener('input', (e) => {
                    this.state.juliaC.y = parseFloat(e.target.value);
                    this.updateUniforms();
                });

                document.getElementById('check-export-frame').addEventListener('change', (e) => {
                    this.showExportFrame = e.target.checked;
                    this.updateExportFrame();
                });
            }

            setPalette(name) {
                const map = { 'default': 0, 'fire': 1, 'forest': 2, 'bw': 3, 'ocean': 4, 'neon': 5, 'sunset': 6, 'electric': 7, 'golden': 8, 'matrix': 9 };
                this.state.palette = map[name] || 0;
                this.updateUniforms();
            }

            saveSettings() {
                localStorage.setItem('fractalSettings', JSON.stringify(this.state));
            }

            loadSettings() {
                const saved = localStorage.getItem('fractalSettings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Filter out barnsley if it was saved
                    if (parsed.fractal === 'barnsley') parsed.fractal = 'mandelbrot';
                    this.state = { ...this.state, ...parsed };

                    // Re-instantiate Decimals from strings/numbers
                    this.state.center.x = new Decimal(this.state.center.x);
                    this.state.center.y = new Decimal(this.state.center.y);

                    document.getElementById('select-fractal').value = this.state.fractal;
                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                    document.getElementById('input-iter').value = this.state.iterations;
                    document.getElementById('val-iter').innerText = this.state.iterations;
                    document.getElementById('input-julia-re').value = this.state.juliaC.x;
                    document.getElementById('input-julia-im').value = this.state.juliaC.y;
                    if (this.state.fractal === 'julia') document.getElementById('julia-controls').classList.remove('hidden');
                    this.updateShader();
                    this.updateUniforms();
                    this.renderFavoritesList();
                }
            }

            addFavorite() {
                const fav = {
                    id: Date.now(),
                    fractal: this.state.fractal,
                    zoom: this.state.zoom,
                    center: { ...this.state.center },
                    iterations: this.state.iterations,
                    palette: this.state.palette,
                    juliaC: { ...this.state.juliaC },
                    timestamp: new Date().toLocaleTimeString()
                };
                this.state.favorites.push(fav);
                this.saveSettings();
                this.renderFavoritesList();
                alert('Saved to favorites!');
            }

            loadFavorite(id) {
                const fav = this.state.favorites.find(f => f.id === id);
                if (fav) {
                    this.state.fractal = fav.fractal;
                    if (this.state.fractal === 'barnsley') this.state.fractal = 'mandelbrot'; // Fallback
                    this.state.zoom = fav.zoom;
                    this.state.center = { x: new Decimal(fav.center.x), y: new Decimal(fav.center.y) };
                    this.state.iterations = fav.iterations;
                    this.state.palette = fav.palette;
                    this.state.juliaC = { ...fav.juliaC };

                    document.getElementById('select-fractal').value = this.state.fractal;
                    document.getElementById('val-zoom').innerText = fav.zoom.toFixed(2);
                    document.getElementById('input-zoom').value = fav.zoom;
                    document.getElementById('input-iter').value = fav.iterations;
                    document.getElementById('val-iter').innerText = fav.iterations;
                    if (fav.fractal === 'julia') {
                         document.getElementById('julia-controls').classList.remove('hidden');
                         document.getElementById('input-julia-re').value = fav.juliaC.x;
                         document.getElementById('input-julia-im').value = fav.juliaC.y;
                    } else document.getElementById('julia-controls').classList.add('hidden');

                    this.updateShader();
                    this.updateUniforms();
                }
            }

            removeFavorite(id) {
                this.state.favorites = this.state.favorites.filter(f => f.id !== id);
                this.saveSettings();
                this.renderFavoritesList();
            }

            renderFavoritesList() {
                const list = document.getElementById('favorites-list');
                list.innerHTML = '';
                if (this.state.favorites.length === 0) {
                    list.innerHTML = '<div class="text-center text-xs text-gray-500 py-4">No favorites yet</div>';
                    return;
                }
                this.state.favorites.forEach(fav => {
                    const el = document.createElement('div');
                    el.className = 'bg-white/10 p-2 rounded flex justify-between items-center';
                    el.innerHTML = `
                        <div class="cursor-pointer flex-1" onclick="window.fractalApp.loadFavorite(${fav.id})">
                            <div class="text-xs font-bold capitalize">${fav.fractal}</div>
                            <div class="text-[10px] text-gray-400">Zoom: ${fav.zoom.toFixed(1)} â€¢ ${fav.timestamp}</div>
                        </div>
                        <button onclick="window.fractalApp.removeFavorite(${fav.id})" class="text-red-400 hover:text-red-200 ml-2">&times;</button>
                    `;
                    list.appendChild(el);
                });
            }

            exportHighRes() {
                const targetW = 3840;
                const targetH = 2160;

                const sw = this.app.screen.width;
                const sh = this.app.screen.height;
                const sMin = Math.min(sw, sh);

                const dims = this.getExportFrameDimensions();
                const frameH = dims.h;

                const exportZoom = (this.state.zoom * sMin) / frameH;

                const renderTexture = PIXI.RenderTexture.create({ width: targetW, height: targetH });

                // Check Deep for export too
                const deep = exportZoom > 50000;
                const type = this.state.fractal;
                let filter;

                const commonUniforms = {
                     uResolution: [targetW, targetH],
                     uMaxIter: this.state.iterations,
                     uPalette: this.state.palette
                };

                const deepUniforms = deep ? {
                     ...commonUniforms,
                     uCenterRe: this.splitDecimal(this.state.center.x),
                     uCenterIm: this.splitDecimal(this.state.center.y),
                     uScale: 3.0 / exportZoom
                } : null;

                const normalUniforms = !deep ? {
                     ...commonUniforms,
                     uCenter: [this.state.center.x.toNumber(), this.state.center.y.toNumber()],
                     uZoom: exportZoom
                } : null;

                if (type === 'mandelbrot') {
                     if (deep) filter = new PIXI.Filter(vertexShader, mandelbrotFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, mandelbrotFrag, normalUniforms);
                }
                else if (type === 'burning_ship') {
                     if (deep) filter = new PIXI.Filter(vertexShader, burningShipFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, burningShipFrag, normalUniforms);
                }
                else if (type === 'tricorn') {
                     if (deep) filter = new PIXI.Filter(vertexShader, tricornFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, tricornFrag, normalUniforms);
                }
                else if (type === 'buffalo') {
                     if (deep) filter = new PIXI.Filter(vertexShader, buffaloFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, buffaloFrag, normalUniforms);
                }
                else if (type === 'celtic') {
                     if (deep) filter = new PIXI.Filter(vertexShader, celticFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, celticFrag, normalUniforms);
                }
                else if (type === 'julia') {
                    if (deep) {
                        filter = new PIXI.Filter(vertexShader, juliaFragDeep, {
                            ...deepUniforms,
                            uJuliaCRe: this.splitDecimal(new Decimal(this.state.juliaC.x)),
                            uJuliaCIm: this.splitDecimal(new Decimal(this.state.juliaC.y))
                        });
                    } else {
                        filter = new PIXI.Filter(vertexShader, juliaFrag, {
                            ...normalUniforms,
                            uJuliaC: [this.state.juliaC.x, this.state.juliaC.y]
                        });
                    }
                }
                else if (type === 'newton') {
                    filter = new PIXI.Filter(vertexShader, newtonFrag, normalUniforms);
                }

                const sprite = new PIXI.Sprite(PIXI.Texture.WHITE);
                sprite.width = targetW;
                sprite.height = targetH;
                sprite.filters = [filter];

                this.app.renderer.render(sprite, { renderTexture });

                this.app.renderer.extract.canvas(renderTexture).toBlob((blob) => {
                    const a = document.createElement('a');
                    document.body.append(a);
                    a.download = `fractal_4k_${Date.now()}.png`;
                    a.href = URL.createObjectURL(blob);
                    a.click();
                    a.remove();
                    renderTexture.destroy(true);
                    sprite.destroy();
                }, 'image/png');
            }
        }

        // Initial setup wrapped in a function to allow enabling/disabling if needed,
        // though for now we just instantiate it.
        const app = new FractalApp();
        window.fractalApp = app;

        let advancedApp = null; // Lazy init

        try { app.loadSettings(); } catch (e) { console.error(e); }

        // Tab Switching Logic
        const tabBasic = document.getElementById('tab-basic');
        const tabAdvanced = document.getElementById('tab-advanced');
        const containerBasic = document.getElementById('canvas-container-basic');
        const containerAdvanced = document.getElementById('canvas-container-advanced');

        function switchToBasic() {
            tabBasic.classList.add('bg-blue-600/50', 'text-white');
            tabBasic.classList.remove('bg-transparent', 'text-gray-400');
            tabAdvanced.classList.add('bg-transparent', 'text-gray-400');
            tabAdvanced.classList.remove('bg-blue-600/50', 'text-white');

            containerBasic.classList.remove('hidden');
            containerAdvanced.classList.add('hidden');

            window.currentApp = app;
            app.app.start();
            if (advancedApp) advancedApp.app.stop();
        }

        function switchToAdvanced() {
            tabAdvanced.classList.add('bg-blue-600/50', 'text-white');
            tabAdvanced.classList.remove('bg-transparent', 'text-gray-400');
            tabBasic.classList.add('bg-transparent', 'text-gray-400');
            tabBasic.classList.remove('bg-blue-600/50', 'text-white');

            containerAdvanced.classList.remove('hidden');
            containerBasic.classList.add('hidden');

            if (!advancedApp) {
                advancedApp = new AdvancedApp();
                window.advancedApp = advancedApp;
            }

            window.currentApp = advancedApp;
            app.app.stop();
            advancedApp.app.start();
        }

        tabBasic.addEventListener('click', switchToBasic);
        tabAdvanced.addEventListener('click', switchToAdvanced);

        document.getElementById('btn-save-fav').addEventListener('click', () => { if (window.currentApp === app) app.addFavorite(); });
        document.getElementById('btn-favorites').addEventListener('click', () => {
             const panel = document.getElementById('favorites-panel');
             if (panel.classList.contains('hidden')) {
                 panel.classList.remove('hidden');
                 panel.classList.add('flex');
                 if (window.currentApp === app) app.renderFavoritesList();
             } else {
                 panel.classList.add('hidden');
                 panel.classList.remove('flex');
             }
        });
        document.getElementById('btn-close-fav').addEventListener('click', () => {
             const panel = document.getElementById('favorites-panel');
             panel.classList.add('hidden');
             panel.classList.remove('flex');
        });

        document.getElementById('btn-export-highres').addEventListener('click', () => { if (window.currentApp === app) app.exportHighRes(); });
        document.getElementById('btn-undo').addEventListener('click', () => { if (window.currentApp === app) app.undo(); });
        document.getElementById('btn-reset').addEventListener('click', () => { if (window.currentApp === app) app.resetView(); });

        window.addEventListener('beforeunload', () => { if (window.currentApp === app) app.saveSettings(); });

        // Track current app
        window.currentApp = app;

    </script>
</body>
</html>
