<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fractal Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.4.3/decimal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; touch-action: none; }
        .noselect { -webkit-user-select: none; user-select: none; }
        canvas { display: block; touch-action: none; }
        /* Scrollbar customization for the UI panel */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.4); }
    </style>
</head>
<body class="text-white font-sans antialiased noselect">
    <!-- PixiJS Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <!-- Export Frame Overlay (Hidden by default) -->
    <div id="export-frame" class="absolute hidden border-2 border-dashed border-yellow-400 pointer-events-none z-50 shadow-[0_0_15px_rgba(255,255,0,0.5)]">
        <div class="absolute top-2 left-2 bg-yellow-400 text-black text-[10px] font-bold px-1 rounded opacity-80">EXPORT AREA (16:9)</div>
    </div>

    <!-- UI Container -->
    <div id="ui-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 flex flex-col justify-between p-4">

        <!-- Header / Top Bar -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="bg-black/60 backdrop-blur-md rounded-lg p-3 border border-white/10 shadow-lg">
                <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">Fractal Explorer</h1>
                <p class="text-xs text-gray-400">Navigate the infinite</p>
            </div>

            <div class="flex gap-2">
                <button id="btn-toggle-controls" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Toggle Controls">
                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                </button>
                <button id="btn-save-fav" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Save Favorite">
                    <svg class="w-5 h-5 text-pink-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>
                </button>
                <button id="btn-favorites" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="View Favorites">
                    <svg class="w-5 h-5 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                </button>
                <button id="btn-undo" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Undo Zoom">
                    <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
                </button>
                <button id="btn-reset" class="bg-black/60 backdrop-blur-md hover:bg-white/10 p-2 rounded-lg border border-white/10 transition" title="Reset View">
                    <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m-15.357-2a8.001 8.001 0 0015.357-2m0 0H15"></path></svg>
                </button>
            </div>
        </div>

        <!-- Sidebar Control Panel -->
        <div id="controls-panel" class="pointer-events-auto bg-black/60 backdrop-blur-md border border-white/10 rounded-lg p-4 w-full max-w-sm mt-4 ml-auto sm:ml-0 overflow-y-auto max-h-[70vh] shadow-2xl transition-transform duration-300">
            <div class="space-y-4">

                <!-- Fractal Selector -->
                <div>
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider mb-1">Fractal Type</label>
                    <select id="select-fractal" class="w-full bg-white/10 border border-white/20 rounded px-2 py-1 text-sm focus:outline-none focus:border-blue-500 transition">
                        <option value="mandelbrot">Mandelbrot Set</option>
                        <option value="burning_ship">Burning Ship</option>
                        <option value="tricorn">Tricorn (Mandelbar)</option>
                        <option value="buffalo">Buffalo Fractal</option>
                        <option value="celtic">Celtic Fractal</option>
                        <option value="julia">Julia Set</option>
                        <option value="newton">Newton Fractal</option>
                    </select>
                </div>

                <!-- Parameters -->
                <div class="space-y-3">
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider">Parameters</label>

                    <div>
                        <div class="flex justify-between text-xs text-gray-300 mb-1">
                            <span>Zoom</span>
                            <span id="val-zoom">1.0</span>
                        </div>
                        <input type="range" id="input-zoom" min="0.1" max="10000" step="0.1" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <div>
                        <div class="flex justify-between text-xs text-gray-300 mb-1">
                            <span>Iterations / Detail</span>
                            <span id="val-iter">100</span>
                        </div>
                        <input type="range" id="input-iter" min="10" max="100000" step="10" value="100" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <!-- Colors -->
                <div>
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider mb-1">Color Palette</label>
                    <div class="flex gap-2">
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-blue-500 to-purple-500 ring-2 ring-white/50 hover:scale-110 transition" onclick="app.setPalette('default')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-red-500 to-yellow-500 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('fire')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-green-400 to-teal-600 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('forest')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-gray-200 to-gray-800 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('bw')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-blue-700 to-cyan-400 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('ocean')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-pink-500 to-cyan-500 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('neon')"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-purple-800 to-orange-400 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('sunset')"></button>
                        <!-- New Palettes -->
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-indigo-700 to-cyan-300 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('electric')" title="Electric"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-yellow-400 to-yellow-900 ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('golden')" title="Golden"></button>
                        <button class="w-6 h-6 rounded-full bg-gradient-to-br from-green-500 to-black ring-1 ring-white/20 hover:scale-110 transition" onclick="app.setPalette('matrix')" title="Matrix"></button>
                    </div>
                </div>

                <!-- Julia Specific -->
                <div id="julia-controls" class="hidden space-y-2 border-t border-white/10 pt-2">
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider">Julia Constant (c)</label>
                    <div class="flex gap-2">
                         <div class="flex-1">
                            <span class="text-[10px] text-gray-400">Re</span>
                            <input type="range" id="input-julia-re" min="-2" max="2" step="0.001" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                         </div>
                         <div class="flex-1">
                            <span class="text-[10px] text-gray-400">Im</span>
                            <input type="range" id="input-julia-im" min="-2" max="2" step="0.001" class="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer">
                         </div>
                    </div>
                </div>

                <!-- Export Controls -->
                <div class="border-t border-white/10 pt-2 space-y-2">
                    <label class="block text-xs font-semibold text-gray-400 uppercase tracking-wider">Export</label>
                    <div class="flex items-center gap-2">
                         <input type="checkbox" id="check-export-frame" class="w-4 h-4 bg-white/20 rounded border-none">
                         <span class="text-xs text-gray-300">Show Export Frame (16:9)</span>
                    </div>
                    <button id="btn-export-highres" class="w-full bg-blue-600/80 hover:bg-blue-600 text-white text-xs font-bold py-2 px-4 rounded transition">
                        Export High-Res (4K)
                    </button>
                </div>

                <div class="text-[10px] text-gray-500 pt-2">
                    Drag/Arrows to Pan â€¢ Scroll/Pinch to Zoom
                </div>
            </div>
        </div>

        <!-- Favorites Panel (Hidden by default) -->
        <div id="favorites-panel" class="pointer-events-auto absolute top-16 right-4 w-64 bg-black/80 backdrop-blur-md border border-white/10 rounded-lg shadow-xl hidden flex-col max-h-[80vh]">
            <div class="p-3 border-b border-white/10 flex justify-between items-center">
                <h3 class="text-sm font-bold">Favorites</h3>
                <button id="btn-close-fav" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="favorites-list" class="flex-1 overflow-y-auto p-2 space-y-2">
                <!-- Favorites Items will be injected here -->
                <div class="text-center text-xs text-gray-500 py-4">No favorites yet</div>
            </div>
        </div>

    </div>

    <script>
        // --- Shaders ---

        const vertexShader = `
            attribute vec2 aVertexPosition;
            attribute vec2 aTextureCoord;

            uniform mat3 projectionMatrix;

            varying vec2 vTextureCoord;

            void main(void) {
                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
                vTextureCoord = aTextureCoord;
            }
        `;

        // Common utility functions for shaders
        const shaderUtils = `
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            vec3 getPaletteColor(float t, int paletteId) {
                // t is cyclic 0..1
                if (paletteId == 1) { // Fire
                    // Use a cyclic heat map
                    float x = t * 2.0;
                    if (x < 1.0) return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), x);
                    return mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 0.8), x - 1.0);
                } else if (paletteId == 2) { // Forest
                    return vec3(0.1 + 0.1*sin(t*6.28), 0.5 + 0.4*sin(t*6.28), 0.1 + 0.1*cos(t*6.28));
                } else if (paletteId == 3) { // BW
                    float v = 0.5 + 0.5 * sin(t * 6.28318);
                    return vec3(v);
                } else if (paletteId == 4) { // Ocean
                    return mix(vec3(0.0, 0.1, 0.4), vec3(0.0, 0.8, 0.9), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 5) { // Neon
                    return hsv2rgb(vec3(t, 1.0, 1.0));
                } else if (paletteId == 6) { // Sunset
                    return mix(vec3(0.2, 0.0, 0.2), vec3(1.0, 0.8, 0.2), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 7) { // Electric
                    // Indigo to Cyan
                    return mix(vec3(0.29, 0.0, 0.51), vec3(0.0, 1.0, 1.0), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 8) { // Golden
                    // Gold to Brown
                    return mix(vec3(1.0, 0.84, 0.0), vec3(0.55, 0.27, 0.07), 0.5 + 0.5*sin(t*6.28));
                } else if (paletteId == 9) { // Matrix
                    // Black to Green
                    float v = fract(t * 3.0);
                    return mix(vec3(0.0), vec3(0.0, 1.0, 0.2), v);
                }
                // Default (Rainbow/Blue-Purple)
                return hsv2rgb(vec3(0.6 + 0.4*t, 0.8, 1.0));
            }

            vec3 getSmoothColor(int iter, float magSq, int maxIter, int paletteId) {
                if (iter == maxIter) return vec3(0.0);

                float smoothIter = float(iter);
                if (magSq > 1.0) {
                    // smooth = iter + 1 - log2(log2(|z|))
                    // log2(|z|) = 0.5 * log2(|z|^2)
                    float logMod = 0.5 * log2(magSq);
                    float mu = log2(logMod);
                    smoothIter = smoothIter + 1.0 - mu;
                }

                // Cyclic coloring: frequency 0.02 (cycle every 50 iterations)
                float t = fract(smoothIter * 0.02);
                return getPaletteColor(t, paletteId);
            }
        `;

        // Double Precision Emulation Lib
        const dsMath = `
            // Double-Single Arithmetic (Emulated Double Precision)
            // Based on standard DS algorithms for GLSL

            vec2 ds_set(float a) { return vec2(a, 0.0); }

            vec2 ds_add(vec2 dsa, vec2 dsb) {
                vec2 dsc;
                float t1, t2, e;
                t1 = dsa.x + dsb.x;
                e = t1 - dsa.x;
                t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;
                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_sub(vec2 dsa, vec2 dsb) {
                vec2 dsc;
                float t1, t2, e;
                t1 = dsa.x - dsb.x;
                e = t1 - dsa.x;
                t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;
                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_mul(vec2 dsa, vec2 dsb) {
                vec2 dsc;
                float c11, c21, c2, e, t1, t2;
                float a = dsa.x;
                float b = dsb.x;

                float cona = a * 4097.0;
                float conb = b * 4097.0;
                float a1 = cona - (cona - a);
                float b1 = conb - (conb - b);
                float a2 = a - a1;
                float b2 = b - b1;

                c11 = a * b;
                c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));

                c2 = dsa.x * dsb.y + dsa.y * dsb.x;

                t1 = c11 + c2;
                e = t1 - c11;
                t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;

                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_sqr(vec2 dsa) {
                vec2 dsc;
                float c11, c21, c2, e, t1, t2;
                float a = dsa.x;
                float cona = a * 4097.0;
                float a1 = cona - (cona - a);
                float a2 = a - a1;

                c11 = a * a;
                c21 = a2 * a2 + (a2 * a1 + (a1 * a2 + (a1 * a1 - c11)));

                c2 = 2.0 * dsa.x * dsa.y;

                t1 = c11 + c2;
                e = t1 - c11;
                t2 = dsa.y * dsa.y + ((c2 - e) + (c11 - (t1 - e))) + c21;

                dsc.x = t1 + t2;
                dsc.y = t2 - (dsc.x - t1);
                return dsc;
            }

            vec2 ds_abs(vec2 a) {
                 if (a.x < 0.0) return vec2(-a.x, -a.y);
                 return a;
            }
        `;

        // Shader Code Definitions

        // 1. Mandelbrot (Normal and Deep)
        const mandelbrotFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);

                // Optimization: Cardioid and Period-2 Bulb Check
                // Cardioid: q * (q + (x-1/4)) < 1/4 * y^2, where q = (x-1/4)^2 + y^2
                float x = c.x;
                float y = c.y;
                float y2 = y * y;
                float q = (x - 0.25) * (x - 0.25) + y2;
                if (q * (q + (x - 0.25)) < 0.25 * y2) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }
                // Period-2 Bulb: (x+1)^2 + y^2 < 1/16
                if ((x + 1.0) * (x + 1.0) + y2 < 0.0625) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }

                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = (z.x * z.x - z.y * z.y) + c.x;
                    float y = (z.y * z.x + z.x * z.y) + c.y;
                    magSq = x * x + y * y;
                    if (magSq > 4.0) {
                        z.x = x; z.y = y; // Save escaped value for smoothing
                        iter++; // Count this iteration
                        break;
                    }
                    z.x = x; z.y = y;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const mandelbrotFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe; // High, Low
            uniform vec2 uCenterIm; // High, Low
            uniform float uScale; // 3.0 / Zoom
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                // Calculate C in Double Precision
                // c_re = CenterRe + uv.x * scale
                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);

                // c_im = CenterIm + uv.y * scale
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0, 0.0);
                vec2 z_im = vec2(0.0, 0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    // z_re_new = z_re^2 - z_im^2 + c_re
                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);
                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 z_re_new = ds_add(term1, c_re);

                    // z_im_new = 2 * z_re * z_im + c_im
                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 z_im_new = ds_add(term2_2, c_im);

                    // Check escape: z_re^2 + z_im^2 > 4.0
                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x; // Use high part of DS for magnitude estimate
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = z_re_new;
                    z_im = z_im_new;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 2. Burning Ship
        const burningShipFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = abs(z.x);
                    float y = abs(z.y);
                    float nx = x * x - y * y + c.x;
                    float ny = 2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const burningShipFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 x = ds_abs(z_re);
                    vec2 y = ds_abs(z_im);

                    vec2 x_sq = ds_sqr(x);
                    vec2 y_sq = ds_sqr(y);

                    vec2 term1 = ds_sub(x_sq, y_sq);
                    vec2 nx = ds_add(term1, c_re);

                    vec2 term2 = ds_mul(x, y);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(x_sq, y_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 3. Tricorn (Mandelbar)
        const tricornFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = z.x;
                    float y = z.y;
                    // conj(z)^2 + c
                    // (x-iy)^2 = x^2 - y^2 - 2ixy
                    // Verified aspect ratio: Tricorn matches scale of Mandelbrot correctly.

                    float nx = x * x - y * y + c.x;
                    float ny = -2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const tricornFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);

                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 nx = ds_add(term1, c_re);

                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_neg = vec2(-term2.x, -term2.y);
                    vec2 term2_2 = ds_add(term2_neg, term2_neg);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 4. Buffalo (Normal and Deep)
        const buffaloFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = abs(z.x);
                    float y = abs(z.y);
                    // Buffalo: |x^2 - y^2| - 2|xy|i + c
                    // |x^2 - y^2| is basically abs(x*x - y*y)
                    // Im part: -2|xy| is -2*abs(x*y)

                    float nx = abs(x * x - y * y) + c.x;
                    float ny = -2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const buffaloFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 x = ds_abs(z_re);
                    vec2 y = ds_abs(z_im);

                    vec2 x_sq = ds_sqr(x);
                    vec2 y_sq = ds_sqr(y);

                    vec2 term1 = ds_sub(x_sq, y_sq);
                    vec2 term1_abs = ds_abs(term1);
                    vec2 nx = ds_add(term1_abs, c_re);

                    vec2 term2 = ds_mul(x, y);
                    vec2 term2_neg = vec2(-term2.x, -term2.y);
                    vec2 term2_2 = ds_add(term2_neg, term2_neg);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(x_sq, y_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 5. Celtic (Normal and Deep)
        const celticFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 c = uCenter + uv * (3.0 / uZoom);
                vec2 z = vec2(0.0);
                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = z.x;
                    float y = z.y;
                    // Celtic: |Re(z^2)| + i*Im(z^2) + c
                    // Re(z^2) = x^2 - y^2
                    // Im(z^2) = 2xy

                    float nx = abs(x * x - y * y) + c.x;
                    float ny = 2.0 * x * y + c.y;

                    magSq = nx * nx + ny * ny;
                    if (magSq > 4.0) {
                        z.x = nx; z.y = ny;
                        iter++;
                        break;
                    }
                    z.x = nx; z.y = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const celticFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                vec2 offsetRe = vec2(uv.x * uScale, 0.0);
                vec2 c_re = ds_add(uCenterRe, offsetRe);
                vec2 offsetIm = vec2(uv.y * uScale, 0.0);
                vec2 c_im = ds_add(uCenterIm, offsetIm);

                vec2 z_re = vec2(0.0);
                vec2 z_im = vec2(0.0);
                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);

                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 term1_abs = ds_abs(term1);
                    vec2 nx = ds_add(term1_abs, c_re);

                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 ny = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = nx;
                    z_im = ny;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 6. Julia (Normal and Deep)
        const juliaFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;
            uniform vec2 uJuliaC;

            ` + shaderUtils + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 z = uCenter + uv * (3.0 / uZoom);
                vec2 c = uJuliaC;

                int iter = 0;
                float magSq = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;
                    float x = (z.x * z.x - z.y * z.y) + c.x;
                    float y = (z.y * z.x + z.x * z.y) + c.y;
                    magSq = x * x + y * y;
                    if (magSq > 4.0) {
                        z.x = x; z.y = y;
                        iter++;
                        break;
                    }
                    z.x = x; z.y = y;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSq, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const juliaFragDeep = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenterRe;
            uniform vec2 uCenterIm;
            uniform float uScale;
            uniform int uMaxIter;
            uniform int uPalette;
            uniform vec2 uJuliaCRe;
            uniform vec2 uJuliaCIm;

            ` + shaderUtils + `
            ` + dsMath + `

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);

                // z = Center + uv * scale
                vec2 z_re = ds_add(uCenterRe, vec2(uv.x * uScale, 0.0));
                vec2 z_im = ds_add(uCenterIm, vec2(uv.y * uScale, 0.0));

                // c is constant
                vec2 c_re = uJuliaCRe;
                vec2 c_im = uJuliaCIm;

                int iter = 0;
                float magSqFloat = 0.0;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z_re_sq = ds_sqr(z_re);
                    vec2 z_im_sq = ds_sqr(z_im);
                    vec2 term1 = ds_sub(z_re_sq, z_im_sq);
                    vec2 z_re_new = ds_add(term1, c_re);

                    vec2 term2 = ds_mul(z_re, z_im);
                    vec2 term2_2 = ds_add(term2, term2);
                    vec2 z_im_new = ds_add(term2_2, c_im);

                    vec2 mag = ds_add(z_re_sq, z_im_sq);
                    if (mag.x > 4.0) {
                        magSqFloat = mag.x;
                        iter++;
                        break;
                    }

                    magSqFloat = mag.x;
                    z_re = z_re_new;
                    z_im = z_im_new;
                    iter++;
                }

                vec3 col = getSmoothColor(iter, magSqFloat, uMaxIter, uPalette);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // 5. Newton (Standard only)
        const newtonFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 uResolution;
            uniform vec2 uCenter;
            uniform float uZoom;
            uniform int uMaxIter;
            uniform int uPalette;

            ` + shaderUtils + `

            vec2 cmul(vec2 a, vec2 b) {
                return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
            }

            vec2 cdiv(vec2 a, vec2 b) {
                float denom = b.x*b.x + b.y*b.y;
                return vec2((a.x*b.x + a.y*b.y)/denom, (a.y*b.x - a.x*b.y)/denom);
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - uResolution.xy * 0.5) / min(uResolution.x, uResolution.y);
                vec2 z = uCenter + uv * (3.0 / uZoom);

                int iter = 0;
                vec2 roots[3];
                roots[0] = vec2(1.0, 0.0);
                roots[1] = vec2(-0.5, 0.866025);
                roots[2] = vec2(-0.5, -0.866025);

                int rootIdx = -1;

                for (int i = 0; i < 100000; i++) {
                    if (i >= uMaxIter) break;

                    vec2 z2 = cmul(z, z);
                    vec2 z3 = cmul(z2, z);
                    vec2 num = z3 - vec2(1.0, 0.0);
                    vec2 den = 3.0 * z2;

                    if (length(den) < 0.0001) break;

                    z = z - cdiv(num, den);

                    for (int r = 0; r < 3; r++) {
                        float d = distance(z, roots[r]);
                        if (d < 0.001) {
                            rootIdx = r;
                            iter = i;
                            break;
                        }
                    }
                    if (rootIdx != -1) break;
                }

                if (rootIdx != -1) {
                    float t = float(iter) / 50.0;
                    vec3 baseCol;
                    if (rootIdx == 0) baseCol = vec3(1.0, 0.2, 0.2);
                    else if (rootIdx == 1) baseCol = vec3(0.2, 1.0, 0.2);
                    else baseCol = vec3(0.2, 0.2, 1.0);

                    gl_FragColor = vec4(baseCol * (1.0 - t), 1.0);
                } else {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                }
            }
        `;


        // --- Application Class ---

        class FractalApp {
            constructor() {
                this.app = new PIXI.Application({
                    resizeTo: window,
                    backgroundColor: 0x000000,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true,
                    powerPreference: "high-performance"
                });

                document.getElementById('canvas-container').appendChild(this.app.view);

                // Default state
                this.defaultState = {
                    fractal: 'mandelbrot',
                    zoom: 1.0,
                    center: { x: new Decimal(-0.5), y: new Decimal(0.0) },
                    iterations: 100,
                    palette: 0,
                    juliaC: { x: -0.7, y: 0.27015 },
                    favorites: []
                };

                // Deep copy manually for Decimal objects
                this.state = {
                    ...this.defaultState,
                    center: { x: new Decimal(this.defaultState.center.x), y: new Decimal(this.defaultState.center.y) },
                    favorites: []
                };
                this.history = [];
                this.showExportFrame = false;

                // Filter container
                this.fractalContainer = new PIXI.Container();
                this.fractalSprite = new PIXI.Sprite(PIXI.Texture.WHITE);
                this.fractalSprite.width = this.app.screen.width;
                this.fractalSprite.height = this.app.screen.height;
                this.fractalContainer.addChild(this.fractalSprite);
                this.app.stage.addChild(this.fractalContainer);

                // Shader Uniforms (Normal) - FIX: Use renderer width/height (physical) for proper resolution mapping
                this.uniforms = {
                    uResolution: [this.app.renderer.width, this.app.renderer.height],
                    uCenter: [this.state.center.x, this.state.center.y],
                    uZoom: this.state.zoom,
                    uMaxIter: this.state.iterations,
                    uPalette: this.state.palette
                };

                // Deep Zoom Uniforms
                this.uniformsDeep = {
                    uResolution: [this.app.renderer.width, this.app.renderer.height],
                    uCenterRe: [0, 0],
                    uCenterIm: [0, 0],
                    uScale: 1.0,
                    uMaxIter: this.state.iterations,
                    uPalette: this.state.palette
                };

                // Initialize Shaders
                // Normal
                this.mandelbrotFilter = new PIXI.Filter(vertexShader, mandelbrotFrag, this.uniforms);
                this.juliaFilter = new PIXI.Filter(vertexShader, juliaFrag, { ...this.uniforms, uJuliaC: [this.state.juliaC.x, this.state.juliaC.y] });
                this.burningShipFilter = new PIXI.Filter(vertexShader, burningShipFrag, this.uniforms);
                this.tricornFilter = new PIXI.Filter(vertexShader, tricornFrag, this.uniforms);
                this.buffaloFilter = new PIXI.Filter(vertexShader, buffaloFrag, this.uniforms);
                this.celticFilter = new PIXI.Filter(vertexShader, celticFrag, this.uniforms);
                this.newtonFilter = new PIXI.Filter(vertexShader, newtonFrag, this.uniforms);

                // Deep
                this.mandelbrotFilterDeep = new PIXI.Filter(vertexShader, mandelbrotFragDeep, this.uniformsDeep);
                this.juliaFilterDeep = new PIXI.Filter(vertexShader, juliaFragDeep, { ...this.uniformsDeep, uJuliaCRe: [0,0], uJuliaCIm: [0,0] });
                this.burningShipFilterDeep = new PIXI.Filter(vertexShader, burningShipFragDeep, this.uniformsDeep);
                this.tricornFilterDeep = new PIXI.Filter(vertexShader, tricornFragDeep, this.uniformsDeep);
                this.buffaloFilterDeep = new PIXI.Filter(vertexShader, buffaloFragDeep, this.uniformsDeep);
                this.celticFilterDeep = new PIXI.Filter(vertexShader, celticFragDeep, this.uniformsDeep);

                // Apply initial shader
                this.updateShader();
                this.updateUniforms();

                // Bind events
                this.bindEvents();

                // Resize handler
                this.app.renderer.on('resize', () => {
                    this.fractalSprite.width = this.app.screen.width;
                    this.fractalSprite.height = this.app.screen.height;

                    // FIX: Update with physical resolution
                    this.uniforms.uResolution = [this.app.renderer.width, this.app.renderer.height];
                    this.uniformsDeep.uResolution = [this.app.renderer.width, this.app.renderer.height];

                    this.updateExportFrame();
                });
            }

            // Helper to split High Precision Decimal to two Float32 (High, Low) for DS Arithmetic
            splitDecimal(decimalVal) {
                const valNumber = decimalVal.toNumber();
                const high = Math.fround(valNumber);
                const low = Math.fround(decimalVal.minus(high).toNumber());
                return [high, low];
            }

            pushState() {
                // Manually serialize Decimal state because JSON.stringify converts them to strings
                // and we want to snapshot values, not references if they were objects (Decimal objects are immutable but let's be safe)
                const snapshot = {
                    ...this.state,
                    center: { x: this.state.center.x.toString(), y: this.state.center.y.toString() },
                    favorites: [] // don't push favorites
                };
                // JSON stringify/parse to clone other primitives deeply
                const clone = JSON.parse(JSON.stringify(snapshot));
                this.history.push(clone);
                if (this.history.length > 20) this.history.shift();
            }

            undo() {
                if (this.history.length === 0) return;
                const prev = this.history.pop();
                const currentFavs = this.state.favorites;

                // Restore state and re-inflate Decimals
                this.state = {
                    ...prev,
                    center: { x: new Decimal(prev.center.x), y: new Decimal(prev.center.y) },
                    favorites: currentFavs
                };

                document.getElementById('select-fractal').value = this.state.fractal;
                document.getElementById('input-zoom').value = this.state.zoom;
                document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                document.getElementById('input-iter').value = this.state.iterations;
                document.getElementById('val-iter').innerText = this.state.iterations;

                if (this.state.fractal === 'julia') {
                    document.getElementById('julia-controls').classList.remove('hidden');
                    document.getElementById('input-julia-re').value = this.state.juliaC.x;
                    document.getElementById('input-julia-im').value = this.state.juliaC.y;
                } else {
                    document.getElementById('julia-controls').classList.add('hidden');
                }

                this.updateShader();
                this.updateUniforms();
            }

            resetView() {
                const favs = this.state.favorites;
                this.pushState();
                this.state = JSON.parse(JSON.stringify(this.defaultState));
                this.state.favorites = favs;

                document.getElementById('select-fractal').value = this.state.fractal;
                document.getElementById('input-zoom').value = 1.0;
                document.getElementById('val-zoom').innerText = "1.00";
                document.getElementById('input-iter').value = this.state.iterations;
                document.getElementById('val-iter').innerText = this.state.iterations;
                document.getElementById('input-julia-re').value = this.state.juliaC.x;
                document.getElementById('input-julia-im').value = this.state.juliaC.y;
                document.getElementById('julia-controls').classList.add('hidden');

                this.updateShader();
                this.updateUniforms();
                this.saveSettings();
            }

            isDeepZoom() {
                // Switch to Deep Mode if zoom is large enough to need it (approx > 50,000)
                return this.state.zoom > 1000.0;
            }

            updateShader() {
                this.fractalContainer.visible = true;
                this.fractalContainer.filters = [];

                const deep = this.isDeepZoom();
                const type = this.state.fractal;

                if (type === 'mandelbrot') {
                    this.fractalContainer.filters = deep ? [this.mandelbrotFilterDeep] : [this.mandelbrotFilter];
                } else if (type === 'burning_ship') {
                    this.fractalContainer.filters = deep ? [this.burningShipFilterDeep] : [this.burningShipFilter];
                } else if (type === 'tricorn') {
                    this.fractalContainer.filters = deep ? [this.tricornFilterDeep] : [this.tricornFilter];
                } else if (type === 'buffalo') {
                    this.fractalContainer.filters = deep ? [this.buffaloFilterDeep] : [this.buffaloFilter];
                } else if (type === 'celtic') {
                    this.fractalContainer.filters = deep ? [this.celticFilterDeep] : [this.celticFilter];
                } else if (type === 'julia') {
                    this.fractalContainer.filters = deep ? [this.juliaFilterDeep] : [this.juliaFilter];
                } else if (type === 'newton') {
                    this.fractalContainer.filters = [this.newtonFilter];
                }
            }

            updateUniforms() {
                const deep = this.isDeepZoom();
                const type = this.state.fractal;

                // Ensure correct filter is applied (if zoom crossed threshold)
                let neededFilter;
                if (type === 'mandelbrot') neededFilter = deep ? this.mandelbrotFilterDeep : this.mandelbrotFilter;
                else if (type === 'burning_ship') neededFilter = deep ? this.burningShipFilterDeep : this.burningShipFilter;
                else if (type === 'tricorn') neededFilter = deep ? this.tricornFilterDeep : this.tricornFilter;
                else if (type === 'buffalo') neededFilter = deep ? this.buffaloFilterDeep : this.buffaloFilter;
                else if (type === 'celtic') neededFilter = deep ? this.celticFilterDeep : this.celticFilter;
                else if (type === 'julia') neededFilter = deep ? this.juliaFilterDeep : this.juliaFilter;
                else if (type === 'newton') neededFilter = this.newtonFilter;

                const currentFilters = this.fractalContainer.filters;
                if (!currentFilters || currentFilters[0] !== neededFilter) {
                    this.fractalContainer.filters = [neededFilter];
                }

                // Update Uniform Values
                if (!deep) {
                    // Standard Uniforms
                    this.uniforms.uCenter = [this.state.center.x, this.state.center.y];
                    this.uniforms.uZoom = this.state.zoom;
                    this.uniforms.uMaxIter = this.state.iterations;
                    this.uniforms.uPalette = this.state.palette;

                    // Propagate to ALL potential standard filters to be safe (or just current)
                    if(type === 'mandelbrot') {
                        this.mandelbrotFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.mandelbrotFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.mandelbrotFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.mandelbrotFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'burning_ship') {
                        this.burningShipFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.burningShipFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.burningShipFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.burningShipFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'tricorn') {
                        this.tricornFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.tricornFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.tricornFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.tricornFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'buffalo') {
                        this.buffaloFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.buffaloFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.buffaloFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.buffaloFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'celtic') {
                        this.celticFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.celticFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.celticFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.celticFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                    else if(type === 'julia') {
                        this.juliaFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.juliaFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.juliaFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.juliaFilter.uniforms.uPalette = this.uniforms.uPalette;
                        this.juliaFilter.uniforms.uJuliaC = [this.state.juliaC.x, this.state.juliaC.y];
                    }
                    else if(type === 'newton') {
                        this.newtonFilter.uniforms.uCenter = this.uniforms.uCenter;
                        this.newtonFilter.uniforms.uZoom = this.uniforms.uZoom;
                        this.newtonFilter.uniforms.uMaxIter = this.uniforms.uMaxIter;
                        this.newtonFilter.uniforms.uPalette = this.uniforms.uPalette;
                    }
                } else {
                    // Deep Uniforms
                    const cx = this.splitDecimal(this.state.center.x);
                    const cy = this.splitDecimal(this.state.center.y);
                    const scale = 3.0 / this.state.zoom;

                    if (type === 'mandelbrot') {
                        this.mandelbrotFilterDeep.uniforms.uCenterRe = cx;
                        this.mandelbrotFilterDeep.uniforms.uCenterIm = cy;
                        this.mandelbrotFilterDeep.uniforms.uScale = scale;
                        this.mandelbrotFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.mandelbrotFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'burning_ship') {
                        this.burningShipFilterDeep.uniforms.uCenterRe = cx;
                        this.burningShipFilterDeep.uniforms.uCenterIm = cy;
                        this.burningShipFilterDeep.uniforms.uScale = scale;
                        this.burningShipFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.burningShipFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'tricorn') {
                        this.tricornFilterDeep.uniforms.uCenterRe = cx;
                        this.tricornFilterDeep.uniforms.uCenterIm = cy;
                        this.tricornFilterDeep.uniforms.uScale = scale;
                        this.tricornFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.tricornFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'buffalo') {
                        this.buffaloFilterDeep.uniforms.uCenterRe = cx;
                        this.buffaloFilterDeep.uniforms.uCenterIm = cy;
                        this.buffaloFilterDeep.uniforms.uScale = scale;
                        this.buffaloFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.buffaloFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'celtic') {
                        this.celticFilterDeep.uniforms.uCenterRe = cx;
                        this.celticFilterDeep.uniforms.uCenterIm = cy;
                        this.celticFilterDeep.uniforms.uScale = scale;
                        this.celticFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.celticFilterDeep.uniforms.uPalette = this.state.palette;
                    }
                    else if (type === 'julia') {
                        // Julia C is stored as number, convert to Decimal for splitting
                        const jcx = this.splitDecimal(new Decimal(this.state.juliaC.x));
                        const jcy = this.splitDecimal(new Decimal(this.state.juliaC.y));

                        this.juliaFilterDeep.uniforms.uCenterRe = cx;
                        this.juliaFilterDeep.uniforms.uCenterIm = cy;
                        this.juliaFilterDeep.uniforms.uScale = scale;
                        this.juliaFilterDeep.uniforms.uMaxIter = this.state.iterations;
                        this.juliaFilterDeep.uniforms.uPalette = this.state.palette;
                        this.juliaFilterDeep.uniforms.uJuliaCRe = jcx;
                        this.juliaFilterDeep.uniforms.uJuliaCIm = jcy;
                    }
                }
            }

            getScaleFactor() {
                return 3.0; // Standardized for all shaders now
            }

            getExportFrameDimensions() {
                const sw = this.app.screen.width;
                const sh = this.app.screen.height;
                const aspect = 16/9;

                // Use 0.75 (75%) instead of 0.9 to avoid overlapping UI
                let w = sw * 0.75;
                let h = w / aspect;

                if (h > sh * 0.75) {
                    h = sh * 0.75;
                    w = h * aspect;
                }
                return { w, h };
            }

            updateExportFrame() {
                const frame = document.getElementById('export-frame');
                if (!this.showExportFrame) {
                    frame.classList.add('hidden');
                    return;
                }

                const dims = this.getExportFrameDimensions();
                const sw = this.app.screen.width;
                const sh = this.app.screen.height;

                frame.style.width = `${dims.w}px`;
                frame.style.height = `${dims.h}px`;
                frame.style.left = `${(sw - dims.w)/2}px`;
                frame.style.top = `${(sh - dims.h)/2}px`;

                frame.classList.remove('hidden');
            }

            bindEvents() {
                const canvas = this.app.view;
                let activePointers = new Map();
                let initialPinchDist = 0;
                let initialZoom = 1;
                let isDragging = false;
                let lastPoint = null;

                const handleStart = (e) => {
                    if(e.type === 'touchstart') e.preventDefault();

                    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                    if (activePointers.size === 1) {
                         this.pushState();
                         isDragging = true;
                         lastPoint = { x: e.clientX, y: e.clientY };
                    } else if (activePointers.size === 2) {
                        isDragging = false;
                        const points = Array.from(activePointers.values());
                        initialPinchDist = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y);
                        initialZoom = this.state.zoom;
                    }
                };

                const handleMove = (e) => {
                    if (!activePointers.has(e.pointerId)) return;
                    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                    if (activePointers.size === 1 && isDragging) {
                        const current = { x: e.clientX, y: e.clientY };
                        const dx = current.x - lastPoint.x;
                        const dy = current.y - lastPoint.y;
                        const scale = this.getScaleFactor() / (this.state.zoom * Math.min(this.app.screen.width, this.app.screen.height));

                        // Use Decimal for accumulation
                        const dxDec = new Decimal(dx).times(scale);
                        const dyDec = new Decimal(dy).times(scale);

                        this.state.center.x = this.state.center.x.minus(dxDec);
                        this.state.center.y = this.state.center.y.plus(dyDec);

                        lastPoint = current;
                        this.updateUniforms();

                    } else if (activePointers.size === 2) {
                        const points = Array.from(activePointers.values());
                        const dist = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y);

                        if (initialPinchDist > 0) {
                            const ratio = dist / initialPinchDist;
                            const newZoom = initialZoom * ratio;
                            this.state.zoom = newZoom;

                            document.getElementById('input-zoom').value = this.state.zoom;
                            document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                            this.updateUniforms();
                        }
                    }
                };

                const handleEnd = (e) => {
                    activePointers.delete(e.pointerId);
                    if (activePointers.size < 2) {
                        initialPinchDist = 0;
                    }
                    if (activePointers.size === 1) {
                         isDragging = true;
                         const p = activePointers.values().next().value;
                         lastPoint = { x: p.x, y: p.y };
                    } else {
                        isDragging = false;
                    }
                };

                canvas.addEventListener('pointerdown', handleStart);
                canvas.addEventListener('pointermove', handleMove);
                canvas.addEventListener('pointerup', handleEnd);
                canvas.addEventListener('pointercancel', handleEnd);
                canvas.addEventListener('pointerout', handleEnd);
                canvas.addEventListener('pointerleave', handleEnd);

                const onWheel = (e) => {
                    e.preventDefault();
                    const rect = this.app.view.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    const w = this.app.screen.width;
                    const h = this.app.screen.height;
                    const minDim = Math.min(w, h);

                    const u = (mx - w * 0.5) / minDim;
                    const v = (h * 0.5 - my) / minDim;

                    const oldZoom = this.state.zoom;
                    const zoomFactor = 1.1;

                    if (e.deltaY < 0) {
                        this.state.zoom *= zoomFactor;
                    } else {
                        this.state.zoom /= zoomFactor;
                    }

                    // term = scale * (1/oldZoom - 1/newZoom)
                    // We can use native JS numbers for term calculation as long as zoom is not huge (it's up to 10^14)
                    // But to be consistent with 'center' which is Decimal, we should cast.
                    // u, v are small floats.

                    const scaleFactor = this.getScaleFactor();
                    const termVal = scaleFactor * (1.0/oldZoom - 1.0/this.state.zoom);
                    const uDec = new Decimal(u);
                    const vDec = new Decimal(v);
                    const termDec = new Decimal(termVal);

                    this.state.center.x = this.state.center.x.plus(uDec.times(termDec));
                    this.state.center.y = this.state.center.y.plus(vDec.times(termDec));

                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);

                    this.updateUniforms();
                };

                canvas.addEventListener('wheel', onWheel, { passive: false });

                const onDblClick = (e) => {
                    e.preventDefault();
                    this.pushState();

                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    const w = this.app.screen.width;
                    const h = this.app.screen.height;
                    const minDim = Math.min(w, h);

                    const u = (mx - w * 0.5) / minDim;
                    const v = (h * 0.5 - my) / minDim;

                    const scale = this.getScaleFactor();
                    // const wx = this.state.center.x + u * (scale / this.state.zoom);
                    // const wy = this.state.center.y + v * (scale / this.state.zoom);

                    const offsetScale = scale / this.state.zoom;
                    const uDec = new Decimal(u);
                    const vDec = new Decimal(v);
                    const osDec = new Decimal(offsetScale);

                    this.state.center.x = this.state.center.x.plus(uDec.times(osDec));
                    this.state.center.y = this.state.center.y.plus(vDec.times(osDec));

                    if (e.altKey) {
                        this.state.zoom /= 2.0;
                    } else {
                        this.state.zoom *= 2.0;
                    }

                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                    this.updateUniforms();
                };

                canvas.addEventListener('dblclick', onDblClick);

                window.addEventListener('keydown', (e) => {
                    const minDim = Math.min(this.app.screen.width, this.app.screen.height);
                    const scale = this.getScaleFactor() / (this.state.zoom * minDim);
                    const stepPixels = 50;
                    const moveStep = new Decimal(stepPixels * scale);

                    if (e.key === 'ArrowUp') { this.pushState(); this.state.center.y = this.state.center.y.plus(moveStep); }
                    else if (e.key === 'ArrowDown') { this.pushState(); this.state.center.y = this.state.center.y.minus(moveStep); }
                    else if (e.key === 'ArrowLeft') { this.pushState(); this.state.center.x = this.state.center.x.minus(moveStep); }
                    else if (e.key === 'ArrowRight') { this.pushState(); this.state.center.x = this.state.center.x.plus(moveStep); }
                    else return;

                    this.updateUniforms();
                });

                document.getElementById('select-fractal').addEventListener('change', (e) => {
                    this.state.fractal = e.target.value;
                    if (this.state.fractal === 'julia') document.getElementById('julia-controls').classList.remove('hidden');
                    else document.getElementById('julia-controls').classList.add('hidden');
                    this.updateShader();
                    this.updateUniforms();
                });

                document.getElementById('input-zoom').addEventListener('input', (e) => {
                    this.state.zoom = parseFloat(e.target.value);
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                    this.updateUniforms();
                });

                document.getElementById('input-iter').addEventListener('input', (e) => {
                    this.state.iterations = parseInt(e.target.value);
                    document.getElementById('val-iter').innerText = this.state.iterations;
                    this.updateUniforms();
                });

                document.getElementById('input-julia-re').addEventListener('input', (e) => {
                    this.state.juliaC.x = parseFloat(e.target.value);
                    this.updateUniforms();
                });
                document.getElementById('input-julia-im').addEventListener('input', (e) => {
                    this.state.juliaC.y = parseFloat(e.target.value);
                    this.updateUniforms();
                });

                document.getElementById('check-export-frame').addEventListener('change', (e) => {
                    this.showExportFrame = e.target.checked;
                    this.updateExportFrame();
                });
            }

            setPalette(name) {
                const map = { 'default': 0, 'fire': 1, 'forest': 2, 'bw': 3, 'ocean': 4, 'neon': 5, 'sunset': 6, 'electric': 7, 'golden': 8, 'matrix': 9 };
                this.state.palette = map[name] || 0;
                this.updateUniforms();
            }

            saveSettings() {
                localStorage.setItem('fractalSettings', JSON.stringify(this.state));
            }

            loadSettings() {
                const saved = localStorage.getItem('fractalSettings');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Filter out barnsley if it was saved
                    if (parsed.fractal === 'barnsley') parsed.fractal = 'mandelbrot';
                    this.state = { ...this.state, ...parsed };

                    // Re-instantiate Decimals from strings/numbers
                    this.state.center.x = new Decimal(this.state.center.x);
                    this.state.center.y = new Decimal(this.state.center.y);

                    document.getElementById('select-fractal').value = this.state.fractal;
                    document.getElementById('input-zoom').value = this.state.zoom;
                    document.getElementById('val-zoom').innerText = this.state.zoom.toFixed(2);
                    document.getElementById('input-iter').value = this.state.iterations;
                    document.getElementById('val-iter').innerText = this.state.iterations;
                    document.getElementById('input-julia-re').value = this.state.juliaC.x;
                    document.getElementById('input-julia-im').value = this.state.juliaC.y;
                    if (this.state.fractal === 'julia') document.getElementById('julia-controls').classList.remove('hidden');
                    this.updateShader();
                    this.updateUniforms();
                    this.renderFavoritesList();
                }
            }

            addFavorite() {
                const fav = {
                    id: Date.now(),
                    fractal: this.state.fractal,
                    zoom: this.state.zoom,
                    center: { ...this.state.center },
                    iterations: this.state.iterations,
                    palette: this.state.palette,
                    juliaC: { ...this.state.juliaC },
                    timestamp: new Date().toLocaleTimeString()
                };
                this.state.favorites.push(fav);
                this.saveSettings();
                this.renderFavoritesList();
                alert('Saved to favorites!');
            }

            loadFavorite(id) {
                const fav = this.state.favorites.find(f => f.id === id);
                if (fav) {
                    this.state.fractal = fav.fractal;
                    if (this.state.fractal === 'barnsley') this.state.fractal = 'mandelbrot'; // Fallback
                    this.state.zoom = fav.zoom;
                    this.state.center = { x: new Decimal(fav.center.x), y: new Decimal(fav.center.y) };
                    this.state.iterations = fav.iterations;
                    this.state.palette = fav.palette;
                    this.state.juliaC = { ...fav.juliaC };

                    document.getElementById('select-fractal').value = this.state.fractal;
                    document.getElementById('val-zoom').innerText = fav.zoom.toFixed(2);
                    document.getElementById('input-zoom').value = fav.zoom;
                    document.getElementById('input-iter').value = fav.iterations;
                    document.getElementById('val-iter').innerText = fav.iterations;
                    if (fav.fractal === 'julia') {
                         document.getElementById('julia-controls').classList.remove('hidden');
                         document.getElementById('input-julia-re').value = fav.juliaC.x;
                         document.getElementById('input-julia-im').value = fav.juliaC.y;
                    } else document.getElementById('julia-controls').classList.add('hidden');

                    this.updateShader();
                    this.updateUniforms();
                }
            }

            removeFavorite(id) {
                this.state.favorites = this.state.favorites.filter(f => f.id !== id);
                this.saveSettings();
                this.renderFavoritesList();
            }

            renderFavoritesList() {
                const list = document.getElementById('favorites-list');
                list.innerHTML = '';
                if (this.state.favorites.length === 0) {
                    list.innerHTML = '<div class="text-center text-xs text-gray-500 py-4">No favorites yet</div>';
                    return;
                }
                this.state.favorites.forEach(fav => {
                    const el = document.createElement('div');
                    el.className = 'bg-white/10 p-2 rounded flex justify-between items-center';
                    el.innerHTML = `
                        <div class="cursor-pointer flex-1" onclick="window.fractalApp.loadFavorite(${fav.id})">
                            <div class="text-xs font-bold capitalize">${fav.fractal}</div>
                            <div class="text-[10px] text-gray-400">Zoom: ${fav.zoom.toFixed(1)} â€¢ ${fav.timestamp}</div>
                        </div>
                        <button onclick="window.fractalApp.removeFavorite(${fav.id})" class="text-red-400 hover:text-red-200 ml-2">&times;</button>
                    `;
                    list.appendChild(el);
                });
            }

            exportHighRes() {
                const targetW = 3840;
                const targetH = 2160;

                const sw = this.app.screen.width;
                const sh = this.app.screen.height;
                const sMin = Math.min(sw, sh);

                const dims = this.getExportFrameDimensions();
                const frameH = dims.h;

                const exportZoom = (this.state.zoom * sMin) / frameH;

                const renderTexture = PIXI.RenderTexture.create({ width: targetW, height: targetH });

                // Check Deep for export too
                const deep = exportZoom > 50000;
                const type = this.state.fractal;
                let filter;

                const commonUniforms = {
                     uResolution: [targetW, targetH],
                     uMaxIter: this.state.iterations,
                     uPalette: this.state.palette
                };

                const deepUniforms = deep ? {
                     ...commonUniforms,
                     uCenterRe: this.splitDecimal(this.state.center.x),
                     uCenterIm: this.splitDecimal(this.state.center.y),
                     uScale: 3.0 / exportZoom
                } : null;

                const normalUniforms = !deep ? {
                     ...commonUniforms,
                     uCenter: [this.state.center.x.toNumber(), this.state.center.y.toNumber()],
                     uZoom: exportZoom
                } : null;

                if (type === 'mandelbrot') {
                     if (deep) filter = new PIXI.Filter(vertexShader, mandelbrotFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, mandelbrotFrag, normalUniforms);
                }
                else if (type === 'burning_ship') {
                     if (deep) filter = new PIXI.Filter(vertexShader, burningShipFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, burningShipFrag, normalUniforms);
                }
                else if (type === 'tricorn') {
                     if (deep) filter = new PIXI.Filter(vertexShader, tricornFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, tricornFrag, normalUniforms);
                }
                else if (type === 'buffalo') {
                     if (deep) filter = new PIXI.Filter(vertexShader, buffaloFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, buffaloFrag, normalUniforms);
                }
                else if (type === 'celtic') {
                     if (deep) filter = new PIXI.Filter(vertexShader, celticFragDeep, deepUniforms);
                     else filter = new PIXI.Filter(vertexShader, celticFrag, normalUniforms);
                }
                else if (type === 'julia') {
                    if (deep) {
                        filter = new PIXI.Filter(vertexShader, juliaFragDeep, {
                            ...deepUniforms,
                            uJuliaCRe: this.splitDecimal(new Decimal(this.state.juliaC.x)),
                            uJuliaCIm: this.splitDecimal(new Decimal(this.state.juliaC.y))
                        });
                    } else {
                        filter = new PIXI.Filter(vertexShader, juliaFrag, {
                            ...normalUniforms,
                            uJuliaC: [this.state.juliaC.x, this.state.juliaC.y]
                        });
                    }
                }
                else if (type === 'newton') {
                    filter = new PIXI.Filter(vertexShader, newtonFrag, normalUniforms);
                }

                const sprite = new PIXI.Sprite(PIXI.Texture.WHITE);
                sprite.width = targetW;
                sprite.height = targetH;
                sprite.filters = [filter];

                this.app.renderer.render(sprite, { renderTexture });

                this.app.renderer.extract.canvas(renderTexture).toBlob((blob) => {
                    const a = document.createElement('a');
                    document.body.append(a);
                    a.download = `fractal_4k_${Date.now()}.png`;
                    a.href = URL.createObjectURL(blob);
                    a.click();
                    a.remove();
                    renderTexture.destroy(true);
                    sprite.destroy();
                }, 'image/png');
            }
        }

        const app = new FractalApp();
        window.fractalApp = app;

        try { app.loadSettings(); } catch (e) { console.error(e); }

        document.getElementById('btn-toggle-controls').addEventListener('click', () => {
             const panel = document.getElementById('controls-panel');
             panel.classList.toggle('hidden');
        });

        document.getElementById('btn-save-fav').addEventListener('click', () => app.addFavorite());
        document.getElementById('btn-favorites').addEventListener('click', () => {
             const panel = document.getElementById('favorites-panel');
             if (panel.classList.contains('hidden')) {
                 panel.classList.remove('hidden');
                 panel.classList.add('flex');
                 app.renderFavoritesList();
             } else {
                 panel.classList.add('hidden');
                 panel.classList.remove('flex');
             }
        });
        document.getElementById('btn-close-fav').addEventListener('click', () => {
             const panel = document.getElementById('favorites-panel');
             panel.classList.add('hidden');
             panel.classList.remove('flex');
        });

        document.getElementById('btn-export-highres').addEventListener('click', () => app.exportHighRes());
        document.getElementById('btn-undo').addEventListener('click', () => app.undo());
        document.getElementById('btn-reset').addEventListener('click', () => app.resetView());

        window.addEventListener('beforeunload', () => app.saveSettings());

    </script>
</body>
</html>
